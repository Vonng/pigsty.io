<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pigsty – 性能</title>
    <link>/zh/tags/%E6%80%A7%E8%83%BD/</link>
    <description>Recent content in 性能 on Pigsty</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 13 Jan 2024 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/zh/tags/%E6%80%A7%E8%83%BD/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Blog: 令人惊叹的PostgreSQL可伸缩性</title>
      <link>/zh/blog/pg/pg-scalability/</link>
      <pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>/zh/blog/pg/pg-scalability/</guid>
      <description>
        
        
        
        <![CDATA[<img src="/zh/blog/pg/pg-scalability/featured_hu02aa61ae1d9de35cbe238d2676170cb9_119633_640x0_resize_q75_catmullrom.jpg" width="640" height="640"/>]]>
        
        &lt;blockquote&gt;
&lt;p&gt;本文概述了 Cloudflare 是如何利用 15 个 PostgreSQL 集群，伸缩到支持每秒 5500 万个请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2009年7月，美国加州，一个创业团队搞了一个名为 Cloudflare 的内容分发网络（CDN），用于加速互请求，让网络访问更稳定且更快捷。他们在发展初期面临着各种挑战，然而其增长速度却十分惊人。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Overall Internet Traffic; PostgreSQL Scalability&#34; src=&#34;/zh/blog/pg/pg-scalability/scalability-1.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;互联网流量全局概览&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在他们承载着 20% 的互联网流量，每秒 5500 万个 HTTP 请求。 而他们仅仅使用 15 个 PostgreSQL 集群就做到了这一点。&lt;/p&gt;
&lt;p&gt;Cloudflare 使用 PostgreSQL 来存储服务元数据，并处理 OLTP 工作负载。然而在同一个集群支持有着多种不同负载类型的租户是一个难题。一个**集群（Cluster）&lt;strong&gt;是一组数据库服务器，一个&lt;/strong&gt;租户（tenant）**是特定用户或用户组专用的隔离数据空间。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;postgresql的可伸缩性&#34;&gt;PostgreSQL的可伸缩性&lt;/h2&gt;
&lt;p&gt;以下是他们如何将 PostgreSQL 的可伸缩性用到极致的。&lt;/p&gt;
&lt;h3 id=&#34;1-争用&#34;&gt;1. 争用&lt;/h3&gt;
&lt;p&gt;大多数客户端都会相互争用 Postgres 连接。但是 Postgres 连接的成本很高，因为每个连接都是操作系统级别的独立进程。而且每个租户都有独特的工作负载类型，所以很难创建一个全局阈值进行限流。&lt;/p&gt;
&lt;p&gt;而且，人工限制行为不端的租户是一项巨大的工作。某个租户可能会发起一个开销巨大的查询，因而阻塞邻居租户的查询饿着他们。同时，一旦查询到达数据库服务器这儿，再想隔离它就很难了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Connection Pooling With PgBouncer&#34; src=&#34;/zh/blog/pg/pg-scalability/scalability-2.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 Pgbouncer 进行连接池化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此他们使用 &lt;em&gt;Pgbouncer&lt;/em&gt; 作为 Postgres 前面的连接池。&lt;strong&gt;PgBouncer&lt;/strong&gt; 将充当 TCP 代理，池化 Postgres 连接。租户连接到 PgBouncer ，而不是直连 Postgres。因而限制了 Postgres 连接的数量，也能防止连接饥饿现象。&lt;/p&gt;
&lt;p&gt;此外，PgBouncer 还通过使用持久连接来规避了创建和销毁数据库连接的高昂开销，也被用于在运行时限流那些发起高开销查询的租户们。&lt;/p&gt;
&lt;h3 id=&#34;2-惊群&#34;&gt;2. 惊群&lt;/h3&gt;
&lt;p&gt;当许多客户端同时查询服务器时就会出现**惊群（Thundering Herd）**的问题，这会导致数据库性能降级。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Thundering Herd Problem&#34; src=&#34;/zh/blog/pg/pg-scalability/scalability-3.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/The_Thundering_Herd_(1925_film)&#34;&gt;惊群&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当应用程序被重新部署时，其状态会初始化，应用会一次性创建许多条数据库连接。因而当当租户争抢 Postgres 连接时，就会引起惊群现象，Cloudflare 使用 &lt;em&gt;PgBouncer&lt;/em&gt; 来限制特定租户创建的 Postgres 连接数。&lt;/p&gt;
&lt;h3 id=&#34;3-性能&#34;&gt;3. 性能&lt;/h3&gt;
&lt;p&gt;Cloudflare 没有在云上运行 PostgreSQL ，而是使用没有任何虚拟化开销的裸金属物理机，以实现最好的性能。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Load Balancing Traffic Between Database Instances&#34; src=&#34;/zh/blog/pg/pg-scalability/scalability-4.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在数据库实例之间对流量做负载均衡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Cloudflare 使用 &lt;em&gt;HAProxy&lt;/em&gt; 作为四层负载均衡，Pgbouncer 将查询转发至 HAProxy，而 HAProxy 负载均衡器会在集群主实例与只读副本之间对流量进行负载均衡。&lt;/p&gt;
&lt;h3 id=&#34;4-并发&#34;&gt;4. 并发&lt;/h3&gt;
&lt;p&gt;如果有许多租户发起并发（Concurrent）查询，性能会下降。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Congestion Avoidance Algorithm Throttling Tenants&#34; src=&#34;/zh/blog/pg/pg-scalability/scalability-5.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拥塞控制限流算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因而 Cloudflare 使用 &lt;em&gt;TCP Vegas 拥塞控制算法&lt;/em&gt; 来对租户限流。这个算法的工作原理是，首先采样每个租户的事务往返 Postgres 的响应时间（RTT），然后只要 RTT 不降级就持续调整连接池大小，因而在出现资源枯竭前就能实现限流。&lt;/p&gt;
&lt;h3 id=&#34;5-排队&#34;&gt;5. 排队&lt;/h3&gt;
&lt;p&gt;Cloudflare 在 PgBouncer 层面使用队列对查询进行排队。查询在队列中的顺序取决于它们的历史资源使用情况，换句话说，需要更多资源的查询会排在队列的尾部。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Ordering Queries in Priority Queue&#34; src=&#34;/zh/blog/pg/pg-scalability/scalability-6.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用优先队列排序查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Cloudflare 只在流量峰时刻启用优先队列以防资源饥饿。换言之在正常流量中，查询不会永远排在队尾。&lt;/p&gt;
&lt;p&gt;这种方法改善了绝大多数查询的延迟（Latency），不过在流量峰时发起大开销查询的租户会观察到更高的延迟。&lt;/p&gt;
&lt;h3 id=&#34;6-高可用&#34;&gt;6. 高可用&lt;/h3&gt;
&lt;p&gt;Cloudflare 使用 &lt;em&gt;Stolon&lt;/em&gt; 集群管控负责 Postgres 的高可用.&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;High Availability of Data Layer With Stolon&#34; src=&#34;/zh/blog/pg/pg-scalability/scalability-7.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 Stolon 负责数据库高可用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sorintlab/stolon&#34;&gt;Stolon&lt;/a&gt; 可用于搭建 Postgres 主从复制，并在出现问题时负责选举 Postgres 集群领导者（主库）并进行故障切换。&lt;/p&gt;
&lt;p&gt;这里的每个数据库集群都会复制到两个区域，每个区域内有三个实例。&lt;/p&gt;
&lt;p&gt;写请求会被路由到主要区域中的主库上，然后异步复制到次要区域，读请求会路由到次要区域中处理。&lt;/p&gt;
&lt;p&gt;Cloudflare 会进行组件间连通性测试以便主动发现网络分区问题，也会进行混沌测试以优化系统韧性，还会配置冗余的网络交换机于路由器来避免网络分区。&lt;/p&gt;
&lt;p&gt;当故障切换结束，主库实例重新上线时，他们会使用 &lt;em&gt;pg_rewind&lt;/em&gt; 工具重放错过的写入变更，来让旧主库重新与集群同步。&lt;/p&gt;
&lt;p&gt;Cloudflare 的 Postgres 主库实例与从库实例加起来超过 100 台。他们组合使用了 操作系统资源管理，排队理论，拥塞控制算法，甚至是 PostgreSQL 统计量来实现 PostgreSQL 的可伸缩性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;评价与讨论&#34;&gt;评价与讨论&lt;/h2&gt;
&lt;p&gt;这是一篇有价值的经验分享，主要介绍了如何使用 Pgbouncer 以解决 PostgreSQL 的可伸缩性（Scalability）问题。五千万 QPS + 20% 的互联网流量，听上去是不小的一个规模。尽管从 PostgreSQL 专家的角度看这里的实践确实写的有些朴素简陋，但是这篇文章确实抛出来了一个有意义的问题 —— PostgreSQL的 &lt;strong&gt;可伸缩性&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;postgresql-的可伸缩性现状&#34;&gt;PostgreSQL 的可伸缩性现状&lt;/h3&gt;
&lt;p&gt;PostgreSQL 在垂直伸缩和水平伸缩能力上享有盛誉。在读请求上，PostgreSQL 没有什么伸缩性问题 —— 因为读写互不阻塞，所以只读查询的吞吐量上限几乎是随投入的资源（CPU）线性增长的，无论是垂直增加 CPU/内存还是水平扩容拖从库，都可以通过加资源解决。&lt;/p&gt;
&lt;p&gt;PostgreSQL 在写入上的伸缩性没有读上那么强，单机 WAL 写入/重放速度达到 100 MB/s ～  300 MB/s 就会遇到软件瓶颈 —— 但对于常规生产 OLTP 负载这已经是一个很大的值了 —— 作为参考，探探这样一个两亿用户千万日活的应用，所有数据库写入的结构化数据率就在 120 MB/s 左右。PostgreSQL 社区也正在讨论通过 DIO/AIO 以及并行WAL重放的方式来进一步拓展此瓶颈。用户也可以考虑使用 Citus 或者其他分库分表中间件实现写入的伸缩扩容。&lt;/p&gt;
&lt;p&gt;在容量上，PostgreSQL 的可伸缩性主要取决于磁盘，本身并没有瓶颈。在 NVMe SSD 单卡64TB的当下，配合压缩卡支持百TB级别的数据容量毫无问题，更大的容量也可以使用 RAID 或使用多个表空间的方式进行支持。社区曾经报告不少百TB量级的OLTP实例，也有零星 PB 级的实例。大实例的挑战主要是备份管理与空间维护上的，而不是性能上的。&lt;/p&gt;
&lt;p&gt;在过去，PostgreSQL 可伸缩性比较为人诟病的一个问题，就是&lt;strong&gt;对海量连接的支持&lt;/strong&gt; （在 PostgreSQL 14 后得到显著改善）。PostgreSQL 和 Oracle 默认的模型一样都使用了多进程架构。这种设计有着更好的可靠性，但在面对海量高并发场景时，这种模型就有些拖后腿了。&lt;/p&gt;
&lt;p&gt;互联网场景下数据库访问模式主要是海量短连接：一个查询过来就创建一条连接，执行完后就销毁连接 —— PHP 以前就是这么干的，所以和使用线程模型的搭档 MySQL 很配。但对于 PostgreSQL 而言，海量的后端进程与频繁的进程创建销毁会浪费大量的软硬件资源，因而在这种场景的性能表现上就些力不从心了。&lt;/p&gt;
&lt;h3 id=&#34;连接池--解决高并发问题&#34;&gt;连接池 —— 解决高并发问题&lt;/h3&gt;
&lt;p&gt;PostgreSQL 推荐默认使用的连接数量约为 CPU 核数的两倍，通常在几十 ～ 几百的范围内会比较合适。互联网场景下动辄以千/以万计的客户端连接如果直连 PostgreSQL，就会产生显著的额外负担。连接池便是为了解决这个问题而出现的 —— 可以说，连接池对于在互联网场景下使用 PostgreSQL 是一个&lt;strong&gt;必选项&lt;/strong&gt;，能够起到化腐朽为神奇的效果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意，PostgreSQL 并非不支持高吞吐，问题的关键在于并发连接的数量 —— 在《PG性能有多强》中，我们在 92 vCPU 的服务器上使用 约 96 条连接压测出 sysbench 点查吞吐量峰值 233 万。而在超出可用资源后，这一最大吞吐随着并发进一步加大而开始缓慢下降。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用连接池有一些显著的好处：首先，数万条客户端连接，可以池化缓冲收敛为几条活跃 Server 连接（使用事务级连接池），极大减少了操作系统上的进程数量与开销，也避免了进程创建销毁的开销。第二点，并发争用的情况因为活跃连接数的减少而大大减小，进一步优化了性能。第三点，突然出现的负载峰值会在连接池上排队，而不是直接打爆数据库，降低了雪崩概率，从而提高了系统的稳定性。&lt;/p&gt;
&lt;h3 id=&#34;性能与瓶颈&#34;&gt;性能与瓶颈&lt;/h3&gt;
&lt;p&gt;我在探探时有很多关于 PgBouncer 的最佳实践，我们有一套核心数据库集群，整个集群有着 50万 QPS，主库上的客户端连接数为两万，写入 TPS 约为 5 万。这样的负载如果直接打到 Postgres 上会立即打爆数据库。因此在应用与数据库之间，还有一个 PgBouncer 连接池中间件。所有两万条客户端连接经过连接池&lt;strong&gt;事务池化&lt;/strong&gt;模式后，总共只需要 5 ～ 8 条活跃服务器连接就支撑起所有的请求，CPU 使用率约为 20%，这是一个非常巨大的性能改善。&lt;/p&gt;
&lt;p&gt;PgBouncer 是一个轻量级连接池，可以部署在用户侧或者数据库侧。PgBouncer 本身因为使用了单进程模式，存在一个 QPS / TPS 瓶颈，约为 3 ～ 5 万。因此为了避免 PgBouncer 本身的单点问题与瓶颈，在核心主库上我们使用了 4 个幂等的 PgBouncer 实例，并通过 HAProxy 均匀分发流量给这四个 PgBouncer 连接池池化后，再到数据库主库上处理。但是对于绝大多数场景而言，单个 PgBouncer 进程的 3万 QPS 的处理能力已经是绰绰有余了。&lt;/p&gt;
&lt;h3 id=&#34;管理灵活性&#34;&gt;管理灵活性&lt;/h3&gt;
&lt;p&gt;PgBouncer 的一个巨大优势是，它可以提供 User / Database / Instance 级别的查询响应时间指标（&lt;strong&gt;RT&lt;/strong&gt;）。这是用于性能衡量的核心指标，对于早些年的 PostgreSQL 老版本，PgBouncer 中的统计值也是获取这类数据的唯一方式。尽管用户可以通过 &lt;code&gt;pg_stat_statements&lt;/code&gt; 扩展获取查询组的 RT， PostgreSQL 14 以后也可以获取数据库级别的会话活跃时间来计算事务 RT，新出现的 eBPF 也可以完成这一点。但 PgBouncer 提供的性能监控数据对于数据库管理仍然是非常重要的参考依据。&lt;/p&gt;
&lt;p&gt;PgBouncer 连接池不仅提供了性能上的改善，还为精细管理提供了抓手。例如在数据库在线不停机迁移中，如果在线流量完全通过连接池访问，那么你就可以通过简单修改 PgBouncer 配置文件的方式，将旧集群的读写流量丝滑重定向到新集群中，甚至都不需要业务方即时参与改配置重启服务。你也可以像上面 Cloudflare 的例子一样，在连接池修改 Database / User 的参数，实现限流的能力。如果某一个数据库租户表现不良，影响了整个共享集群，管理员可以在 PgBouncer 上轻松实现限流与阻断的能力。&lt;/p&gt;
&lt;h3 id=&#34;其他替代品&#34;&gt;其他替代品&lt;/h3&gt;
&lt;p&gt;PostgreSQL 生态中还有其他的一些连接池产品。与 PgBouncer 同期的 PGPool-II 也曾经是一个有力竞争者：它提供了更为强大的负载均衡/读写分离等能力，也能充分利用多核的能力，但是对 PostgreSQL 数据库本身有侵入性 —— 需要安装扩展才能用，而且曾经有比较显著的性能折损（30%）。所以在连接池大PK中，简单轻量的 PgBouncer 成为了胜利者，占据了PG连接池的主流生态位。&lt;/p&gt;
&lt;p&gt;除了 PgBouncer 之外，新的 PostgreSQL 连接池项目也在不断出现，比如 Odyssey，pgcat，pgagroal，ZQPool 等。我非常期待能有一个完全兼容 PgBouncer 的高性能/更易用原位替代出现。&lt;/p&gt;
&lt;p&gt;此外，许多编程语言标准库的数据库驱动里，都开始内置了连接池，加上 PostgreSQL 14 的改进让多个进程的开销减少。以及硬件性能的指数增长（现在都有 512 vCPU 的服务器了，内存也不是啥稀缺资源了）。所以有时候不用连接池，几千个连接直接干上去也是一个可行选项了。&lt;/p&gt;
&lt;h3 id=&#34;我能用上-cloudflare-的实践吗&#34;&gt;我能用上 Cloudflare 的实践吗？&lt;/h3&gt;
&lt;p&gt;随着硬件性能的不断提升，软件架构的不断优化，管理最佳实践的逐渐普及 —— 高可用、高并发、高性能（可伸缩性）对于互联网公司来说属于老生常谈，基本不算什么新鲜技术了。&lt;/p&gt;
&lt;p&gt;例如在当下，随便一个初级 DBA / 运维，只要使用 Pigsty 部署一套 PostgreSQL 集群都可以轻松做到这一点，包括 Cloudflare 提到的 Pgbouncer 连接池，以及高可用组件 Stolon 的上位替代 Patroni ，都已经做到开箱即用了。只要硬件达标，轻松处理好海量并发百万请求不是梦。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在本世纪初，一台 Apache 服务器只能处理很可怜的一两百个并发请求。最优秀的软件也很难处理上万的并发 —— 业界有个著名的 &lt;strong&gt;C10K 高并发&lt;/strong&gt; 问题，谁要是能做到几千并发，那就是业界高手。但随着 Epoll 和 Nginx 在 2003/2004 年相继问世，“高并发” 不再是什么难题了 —— 随便一个小白只要学会配置 Nginx，就可以达到前几年大师们做梦都不敢想的程度 —— 瑞典马工《&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&amp;mid=2247486387&amp;idx=1&amp;sn=20ac92e33ed5a6b8e3120e99aefaf1cc&amp;scene=21#wechat_redirect&#34;&gt;云厂商眼中的客户：又穷又闲又缺爱&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就跟现在随便哪个新手都可以拿 Nginx 实现以前用 httpd 的大师们想都不敢想的 Web 海量请求与高并发一样。PostgreSQL 的可伸缩性也随着 PgBouncer 的普及走入千家万户。&lt;/p&gt;
&lt;p&gt;例如，在 Pigsty 中，默认为所有 PostgreSQL 1:1 部署了 PgBouncer 实例，使用事务池化模式，并纳入监控。而默认的 Primary 与 Replica 服务也是通过 PgBouncer 访问 Postgres 数据库的。用户不需要操心太多与 PgBouncer 有关的细节 —— 例如， PgBouncer 的数据库与用户是在通过剧本创建 Postgres 数据库/用户时自动维护的。一些常见的配置注意事项和坑也在预置配置模板中进行了规避，力求做到开箱即用。&lt;/p&gt;
&lt;p&gt;当然，对于非互联网场景的应用，PgBouncer 也并非必须品。而且默认的 Transaction Pooling 虽然在性能上非常优秀，但也是以牺牲了一些会话级功能为代价的。所以您也完全可以配置 Primary / Replica 服务直连 Postgres，绕过 PgBouncer；或者使用兼容性最好的 Session Pooling 模式。&lt;/p&gt;
&lt;p&gt;总的来说，PgBouncer 确实是一个非常实用的 PostgreSQL 生态工具。如果您的系统对于 PostgreSQL 客户端并发连接数有着较高要求，那么在测试性能时请务必试一试这款中间件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&#34;https://newsletter.systemdesign.one/p/postgresql-scalability&#34;&gt;Cloudflare是如何用15个PG集群支持55M QPS的&lt;/a&gt; |&lt;/p&gt;
&lt;/blockquote&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: PostgreSQL 宏观查询优化之 pg_stat_statements</title>
      <link>/zh/blog/admin/pgss/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>/zh/blog/admin/pgss/</guid>
      <description>
        
        
        
        <![CDATA[<img src="/zh/blog/admin/pgss/featured_hu75d0d77f7fbfe2fbd386d7c04570e341_381888_640x0_resize_q75_catmullrom.jpg" width="640" height="640"/>]]>
        
        &lt;p&gt;在线业务数据库中，慢查询不仅影响终端用户体验，还会浪费系统资源、拉高资源饱和度、导致死锁和事务冲突，增加数据库连接压力，导致主从复制延迟等问题。因此，&lt;strong&gt;查询优化&lt;/strong&gt;是 DBA 的核心工作内容之一。&lt;/p&gt;
&lt;p&gt;在查询优化这条路上，有两种不同的方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宏观优化&lt;/strong&gt;：整体分析工作负载，对其进行剖分下钻，自上而下地识别并改进其中表现最糟糕的部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微观优化&lt;/strong&gt;：分析并改进一条特定的查询，这便需要记录慢查询日志，掌握 EXPLAIN 的玄机，领悟执行计划的奥妙。&lt;/p&gt;
&lt;p&gt;今天我们先来说说前者，&lt;strong&gt;宏观优化&lt;/strong&gt;有三个主要目标与动机：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少资源消耗&lt;/strong&gt;：降低资源饱和的风险，优化CPU/内存/IO，通常以查询&lt;strong&gt;总耗时/总IO&lt;/strong&gt;作为优化目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改善用户体验&lt;/strong&gt;：最常见的优化目标，在OLTP系统中通常以降低&lt;strong&gt;查询平均响应时间&lt;/strong&gt;作为优化目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平衡工作负载&lt;/strong&gt;：确保不同查询组之间的资源使用/性能表现的比例关系得当。&lt;/p&gt;
&lt;p&gt;实现这些目标的关键在于&lt;strong&gt;数据支撑&lt;/strong&gt;，但是数据从哪里来？&lt;/p&gt;
&lt;p&gt;—— &lt;strong&gt;pg_stat_statements&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-1.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-1.png&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;扩展插件pgss&#34;&gt;扩展插件：PGSS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;pg_stat_statements&lt;/strong&gt;，以下简称 &lt;strong&gt;PGSS&lt;/strong&gt; ，是践行观宏之道的核心工具。&lt;/p&gt;
&lt;p&gt;PGSS 出自 PostgreSQL 全球开发组官方之手，以第一方扩展插件的形式，随数据库内核本体一并发行，提供了跟踪 SQL 查询语句级别指标的方法。&lt;/p&gt;
&lt;p&gt;PostgreSQL 生态中有许许多多的扩展，但如果说有哪一个是“&lt;strong&gt;必选&lt;/strong&gt;”的，我必定会毫不犹豫的回答：&lt;strong&gt;PGSS&lt;/strong&gt;。这也是在 &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&amp;mid=2247486135&amp;idx=1&amp;sn=7d9c4920e94efba5d0e0b6af467f596c&amp;chksm=fe4b3f6cc93cb67ac570d5280b37328aed392598b13df88545ff0a06f99630801fc999db8de5&amp;scene=21#wechat_redirect&#34;&gt;&lt;strong&gt;Pigsty&lt;/strong&gt;&lt;/a&gt; 中，我们宁愿“自作主张”，也要默认启用并主动加载的两个扩展之一。（另一个是用于微观优化的 auto_explain）&lt;/p&gt;
&lt;p&gt;PGSS 需要在 &lt;strong&gt;shared_preload_library&lt;/strong&gt; 中显式指定加载，并在数据库中通过 &lt;strong&gt;CREATE EXTENSION&lt;/strong&gt; 显式创建。创建扩展后即可通过视图 &lt;strong&gt;pg_stat_statements&lt;/strong&gt; 访问查询的统计信息。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;PGSS&lt;/strong&gt; 中，系统中的每一类查询（即抽取变量后，执行计划相同的查询）都会被分配一个查询ID，紧接着是调用次数，执行总耗时，以及各种其他指标，其完整模式定义如下（PG15+）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;TABLE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;pg_stat_statements&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;userid&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;                 &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;OID&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （标签值）执行此语句的用户 OID（标签值）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dbid&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;                   &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;OID&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （标签值）此语句所在的数据库 OID（标签值）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;toplevel&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;               &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;BOOL&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （标签值）此语句是否是顶层 SQL 语句（标签值）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;queryid&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;                &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （标签值）查询ID：标准化查询的哈希值（标签值）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;query&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;                  &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;TEXT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （标签值）标准化查询语句的文本内容
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;plans&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;                  &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）此语句被 PLAN 的次数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;total_plan_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）此语句花费在 PLAN 上的总时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;min_plan_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （测量值）PLAN 的最小时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;max_plan_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （测量值）PLAN 的最大时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mean_plan_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;         &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （测量值）PLAN 的平均时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;stddev_plan_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;       &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （测量值）PLAN 时间的标准差
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;calls&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;                  &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）此语句被调用执行的次数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;total_exec_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）此语句花费在执行上的总时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;min_exec_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （测量值）执行的最小时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;max_exec_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （测量值）执行的最大时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mean_exec_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;         &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （测量值）执行的平均时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;stddev_exec_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;       &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （测量值）执行时间的标准差
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;rows&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;                   &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）执行此语句返回的总行数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;shared_blks_hit&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）命中的共享缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;shared_blks_read&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;       &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）读取的共享缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;shared_blks_dirtied&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）写脏的共享缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;shared_blks_written&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）写入磁盘的共享缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;local_blks_hit&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;         &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）命中的本地缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;local_blks_read&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）读取的本地缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;local_blks_dirtied&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）写脏的本地缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;local_blks_written&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）写入磁盘的本地缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;temp_blks_read&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;         &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）读取的临时缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;temp_blks_written&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）写入磁盘的临时缓冲区总块数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;blk_read_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）读取块花费的总时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;blk_write_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;         &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）写入块花费的总时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wal_records&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;            &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）生成 WAL 的记录总数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wal_fpi&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;                &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）生成的 WAL全页镜像总数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wal_bytes&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;              &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;NUMERIC&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）生成的 WAL 字节总数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;jit_functions&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）JIT 编译的函数数量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;jit_generation_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）生成 JIT 字节码的总时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;jit_inlining_count&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）函数被内联的次数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;jit_inlining_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）花费在内联函数上的总时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;jit_optimization_count&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）查询被 JIT优化的次数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;jit_optimization_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）花费在JIT优化上的总时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;jit_emission_count&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;BIGINT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）代码被 JIT Emit的次数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;jit_emission_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;FLOAT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- （累积量）花费在 JIT Emit上的总时长
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;KEY&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;userid&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dbid&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;queryid&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;toplevel&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;PGSS 视图的 SQL 定义（PG 15+版本）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PGSS&lt;/strong&gt; 也有一些局限性：首先，&lt;strong&gt;正在执行中&lt;/strong&gt;的查询语句并不会纳入这里的统计，而需要从 &lt;strong&gt;pg_stat_activity&lt;/strong&gt; 中查看获取。其次，执行失败的查询（例如，因为 statement_timeout 超时被取消的语句）也不会被计入这里的统计 —— 这是&lt;strong&gt;错误分析&lt;/strong&gt;要解决的问题，而不是&lt;strong&gt;查询优化&lt;/strong&gt;所关心的目标。&lt;/p&gt;
&lt;p&gt;最后，查询标识符 &lt;strong&gt;queryid&lt;/strong&gt; 的稳定性需要特别注意：当数据库二进制版本和系统数据目录完全相同时，同一类查询会具有相同的 &lt;strong&gt;queryid&lt;/strong&gt; （即在物理复制的主从上，同类查询的 &lt;strong&gt;queryid&lt;/strong&gt; 默认是相同的），然而对于逻辑复制则不然。但用户不应当对这一性质抱有过度的依赖与假设。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;原始数据&#34;&gt;原始数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;PGSS&lt;/strong&gt; 视图中的列可以分为三类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述性的标签列（Label）&lt;/strong&gt;：查询ID（queryid）、数据库 ID（dbid）、用户（userid），一个顶层查询标记，和标准化的查询文本（query）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测量性的指标（Gauge）&lt;/strong&gt;：与最小、最大、均值标准差有关的八列统计量，以 min，max，mean，stddev 作为前缀，以 plan_time 与 exec_time 作为后缀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;累积性的指标（Counter）&lt;/strong&gt;：除了上面八列与标签列的&lt;strong&gt;其他指标&lt;/strong&gt;，例如 calls、rows 等，最重要、最有用的指标都在这一类里。&lt;/p&gt;
&lt;p&gt;首先解释一下 queryid：queryid 是查询语句被解析后，剥离常量后生成规范化查询的哈希值，因此可以用来标识&lt;strong&gt;同一类查询&lt;/strong&gt;。不同的查询语句可能有着同样的 queryid （规范化后结构一样），同样的查询语句也可能有着不同的 queryid （例如因为 search_path 不同，导致实际查询的表不懂）。&lt;/p&gt;
&lt;p&gt;同样的查询可能会在不同的数据库中被不同的用户所执行。因此在 PGSS 视图中，queryid，dbid，userid，toplevel 四个标签列，共同组成了唯一标识一条记录的“主键”。&lt;/p&gt;
&lt;p&gt;对于指标列而言，&lt;strong&gt;测量性质的指标（GAUGE）&lt;/strong&gt; 主要是执行时间与计划时间相关的八个统计量，然而用户没有办法很好地控制这些统计量的统计范围，所以实用价值并不大。&lt;/p&gt;
&lt;p&gt;真正重要的指标是&lt;strong&gt;累积性的指标（Counter）&lt;/strong&gt;，例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;calls&lt;/strong&gt; ：此查询组发生了多少次调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;total_exec_time&lt;/strong&gt; + &lt;strong&gt;total_plan_time&lt;/strong&gt;：查询组累计耗费时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rows&lt;/strong&gt;：查询组累计返回了多少行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;shared_blks_hit&lt;/strong&gt; + &lt;strong&gt;shared_blks_read&lt;/strong&gt;：缓冲池累计命中和读取操作次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wal_bytes&lt;/strong&gt;：此组中的查询累计生成的 WAL 字节数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;blk_read_time&lt;/strong&gt; 和 &lt;strong&gt;blk_write_time&lt;/strong&gt;：累计花费在块读写IO上的时间&lt;/p&gt;
&lt;p&gt;这里，最有意义的指标是 &lt;strong&gt;calls&lt;/strong&gt; 与 &lt;strong&gt;total_exec_time&lt;/strong&gt;，可以用于计算查询组的核心指标 &lt;strong&gt;QPS&lt;/strong&gt; （吞吐量）与 &lt;strong&gt;RT&lt;/strong&gt;（延迟/响应时间），但其他的指标也很有参考价值。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-2.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可视化展现 PGSS 视图的某个查询组快照&lt;/p&gt;
&lt;p&gt;要解读累积性指标数据，只有某一个时刻的数据是不够的。&lt;strong&gt;我们需要对比至少两个时刻的&lt;strong&gt;&lt;strong&gt;快照&lt;/strong&gt;&lt;/strong&gt;，才能得到有意义的结论&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;作为特例，如果您感兴趣的范围正好是从统计周期伊始（通常是启用此扩展时）至今，那么确实不需要对比“两个快照”。但用户感兴趣的时间粒度通常并不会这么粗放，而往往是以分钟、小时、天为单位。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-3.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-3.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据多个 PGSS 查询组快照计算历史时序指标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好在类似 &lt;a href=&#34;https://pigsty.cc&#34;&gt;Pigsty&lt;/a&gt; 监控系统这样的工具会定期（默认每隔10s）截取头部查询（耗时Top256）的快照。有了许多不同类型的累积指标 M（etrics）在不同时刻的快照之后，我们就能计算出某个累积性指标的三种重要派生指标：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dM/dt&lt;/strong&gt; ：指标 M 基于时间的微分，即每秒的增量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dM/dc&lt;/strong&gt;：指标 M 基于调用次数的微分，即每次调用的平均增量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;%M&lt;/strong&gt;：指标 M 在整个工作负载中所占的百分比。&lt;/p&gt;
&lt;p&gt;这三类指标正好与宏观优化的三类目标相对应，对时间的微分 &lt;strong&gt;dM/dt&lt;/strong&gt; 揭示了&lt;strong&gt;每秒资源使用量&lt;/strong&gt;，通常用于减少资源消耗的优化目标。对调用次数的微分 &lt;strong&gt;dM/dc&lt;/strong&gt; 揭示了&lt;strong&gt;每次调用的资源使用量&lt;/strong&gt;，通常用于改善用户体验的优化目标。而百分比指标 &lt;strong&gt;%M&lt;/strong&gt; 展示了查询组在整个工作负载中所占的百分比，通常用于平衡工作负载的优化目标。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;对时间微分&#34;&gt;对时间微分&lt;/h2&gt;
&lt;p&gt;让我们首先来看第一类指标：对时间的微分。在这里，我们可以使用的指标 M 包括：calls，total_exec_time，rows，wal_bytes，shared_blks_hit + shared_blks_read，以及 blk_read_time + blk_write_time。其他的指标也有参考意义，但让我们从最重要的开始。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-4.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-4.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可视化展现对时间的微分指标 dM/dt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;计算这些指标的方式其实很简单，我们只需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先计算两个快照之间的指标值 M 的差值：&lt;strong&gt;M2 - M1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后计算两个快照之间的时间差值：&lt;strong&gt;t2 - t1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最终计算 &lt;strong&gt;(M2 - M1) / (t2 - t1)&lt;/strong&gt; 即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;生产环境通常会使用 5s，10s，15s，30s，60s 这样的数据采样间隔。对于负载分析通常会使用 1m， 5m，15m 作为常用的分析窗口大小。&lt;/p&gt;
&lt;p&gt;例如，当我们计算 QPS 时，就会分别计算最近 1分钟，5分钟，15分钟的 QPS。窗口越长曲线就越平稳，更能反映长期变化趋势；但是会隐藏短期波动细节，不利于发现瞬时异常波动，所以不同粒度的指标需要结合来看。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-5.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-5.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;展示特定查询组 1/5/15 分钟窗口下的 QPS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您使用 Pigsty / Prometheus 来采集监控数据，那么可以使用 PromQL 简单地完成这些计算工作。例如，计算所有查询最近1分钟的 QPS 指标，使用以下语句就可以了： rate(pg_query_calls{}[1m])&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QPS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 calls 时，对时间求导的结果是 QPS，它的单位是每秒查询数（req/s），这是一个非常基础的指标。查询 QPS 属于吞吐量指标，直接反应了业务施加的负载状况，如果一个查询的吞吐量过高（例如，10000+）或者过低（例如，1-），有可能是值得关注的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-6.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-6.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;QPS：1/5/15 分钟 µ/CV， ±1/3σ分布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们把所有查询组的 QPS 指标累加起来（且没超过PGSS的收集范围），就会得到所谓的 “全局QPS”。另一种获得全局 QPS 的方式是在客户端打点，在类似 Pgbouncer 的连接池中间件上采集，或者使用 ebpf 探测。但都不如 PGSS 方便。&lt;/p&gt;
&lt;p&gt;请注意，QPS 指标并不具备负载意义上的&lt;strong&gt;横向可比性&lt;/strong&gt;。不同查询组可能有着同样的 QPS，而单个查询的耗时却天差地别。甚至同一个查询组在不同时间点上产生的负载水平，也可能因为执行计划不同而发生巨大变化。每秒执行时长是一个更好的衡量负载的指标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每秒执行时长&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 total_exec_time （+ total_plan_time，可选 ）时，我们就会得到宏观优化中最重要的指标之一：在查询组上耗费的的执行时间，有意思的是，这个导数的单位是 秒/每秒，所以分子分母相互约掉了，使得它实际上是一个无量纲的指标。&lt;/p&gt;
&lt;p&gt;这个指标的涵义是：服务器每秒钟花费多少秒来处理这个查询组中的查询，例如 2 s/s 意味着服务器每秒花费两秒执行时间在这组查询上；对于多核CPU，这当然是有可能的：把两个CPU核的全部时间都拿来就行了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-7.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-7.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每秒执行时长：1/5/15 分钟均值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此这里的值也可以理解为一个百分比：可以超过 100%，在这种视角下，它是一个类似于主机 load1, load5, load15 的指标，揭示了该查询组产生的&lt;strong&gt;负载水平&lt;/strong&gt;。如果除以 CPU 核数，甚至可以得到归一化的查询负载贡献度指标。&lt;/p&gt;
&lt;p&gt;但是我们需要注意的是，执行时间中包括了等待锁，等待I/O的时间。所以确实可能出现这样的情况：查询执行时间很长，但却没有对 CPU 负载产生影响。所以如果要精细分析慢查询，我们还要参考&lt;strong&gt;等待事件&lt;/strong&gt;来进一步分析才行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每秒行数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 rows 时，我们会得到每秒该查询组返回的行数，单位是行/每秒（rows/s）。例如 10000 rows/s 意味着该类查询每秒向客户端吐出1万行数据。返回的行需要耗费客户端的处理资源，当我们需要检视应用客户端的数据处理压力时，这是一个非常有参考意义的指标。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-8.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-8.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每秒返回的行数：1/5/15 分钟均值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;共享缓冲区访问带宽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 shared_blks_hit + shared_blks_read 时，我们会得到每秒命中/读取的共享缓冲区块数，如果将其乘以默认块大小 8KiB（极少情况下有可能会是其他的大小，例如32KiB），我们就会得到一类查询“访问”内存磁盘的带宽：单位是字节/秒。&lt;/p&gt;
&lt;p&gt;举个例子，如果某一类查询每秒访问50万次共享缓冲区，折合 3.8 GiB/s 的内部访问数据流：那么这就是一个显著负载，也许会是一个很好的优化候选项。也许你应该检查一下这个查询，看看它是否配得上这些“资源消耗”。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-9.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-9.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;共享缓冲区访问带宽与缓冲区命中率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一个值得参考的衍生指标是缓冲区命中率：即 hit / (hit + read) ，它可以用于分析性能变化的可能原因 —— 缓存未命中。当然，重复访问同一个共享缓冲池里的块，并不会真的重新读取，即使真的去读取，也不一定是读取磁盘，有可能是读内存中的FS Cache。所以这里只是一个参考值，但它确实是一个非常重要的宏观查询优化参考指标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WAL日志量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 wal_bytes 时，我们得到了该查询生成 WAL 的速率，单位是字节/每秒（B/s）。这个指标是在 PostgreSQL 13 新引入的，可以用来定量揭示查询产生的 WAL 大小：写入的 WAL 越多越快，刷写磁盘、物理复制/逻辑复制、日志归档的压力就会越大。&lt;/p&gt;
&lt;p&gt;一个典型的例子是：&lt;code&gt;BEGIN; DELETE FROM xxx; ROLLBACK;&lt;/code&gt; 。这样的事务删了很多数据，产生了大量 WAL 却没有执行任何有用的工作，通过这个指标可以将其揪出来。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-10.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-10.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WAL字节率：1/5/15 分钟均值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里有两个注意事项：上面我们说过，PGSS 无法跟踪执行失败的语句，但这里事务虽然 &lt;strong&gt;ROLLBACK&lt;/strong&gt; 失败了，但是语句却是成功执行了的，所以会被 PGSS 跟踪记录。&lt;/p&gt;
&lt;p&gt;第二件事是：在 PostgreSQL 中并非仅仅是 INSERT/UPDATE/DELETE 会产生 WAL 日志，SELECT 操作也有可能产生 WAL 日志，因为 SELECT 可能会修改元组上的标记（Hint Bit）让页面校验和出现变化，触发 WAL 日志写入。&lt;/p&gt;
&lt;p&gt;甚至存在这种可能，如果读取负载非常大，它会有较大概率导致 FPI 镜像生成，产生可观的 WAL 日志量。你可以通过进一步检查 wal_fpi 指标。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-11.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-11.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;共享缓冲区写脏/写回带宽&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 13 以下的版本，共享缓冲区写脏/写回带宽指标可以作为一个近似下位替代，用于分析查询组的写入负载特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O耗时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 blks_read_time + blks_write_time ，我们会得到查询组花费在块 I/O 上的耗时比例，单位是 “秒/每秒”，与每秒执行时长指标一样，它也反映出一样操作占用的时间比例。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I/O 耗时对于分析查询毛刺原因很有帮助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为 PostgreSQL 会使用操作系统提供的 FS Cache，所以即使这里执行了块读取/写入，可能在文件系统层面上仍然是发生在内存中的缓冲操作。所以它只能作为一个参考指标，使用时需要谨慎，需要与主机节点上的磁盘 I/O 监控相互对照。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对时间微分的指标&lt;/strong&gt; &lt;strong&gt;dM/dt&lt;/strong&gt;，可以展现出一个数据库实例/集群内部工作负载的全貌，对于优化资源使用的场景来说尤其有用。但是如果您的优化目标是改善用户体验，那么可能另一组指标 —— &lt;strong&gt;对调用次数的微分 dM/dc&lt;/strong&gt;，会更有参考意义。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;对调用次数微分&#34;&gt;对调用次数微分&lt;/h2&gt;
&lt;p&gt;上面我们已经计算了六类重要指标对于&lt;strong&gt;时间&lt;/strong&gt;的微分，另一类衍生指标计算方式是对 “&lt;strong&gt;调用次数&lt;/strong&gt;” 进行微分，也就是分母从时间差变成了 QPS。&lt;/p&gt;
&lt;p&gt;这类指标重要性相比前者甚至更高，因为它提供了直接关乎用户体验的几个核心指标，比如最重要的 —— &lt;strong&gt;查询响应时间&lt;/strong&gt; &lt;strong&gt;（RT，Response Time）&lt;/strong&gt;，或曰 &lt;strong&gt;延迟（Latency）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;计算这些指标的方式也很简单，我们只需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算两个快照之间的指标值 M 的差值：&lt;strong&gt;M2 - M1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后计算两个快照之间的 calls 差值：&lt;strong&gt;c2 - c1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后计算 &lt;strong&gt;(M2 - M1) / (c2 - c1)&lt;/strong&gt; 即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 PromQL 实现来说，对于&lt;strong&gt;调用次数的微分指标 dM/dc&lt;/strong&gt;，可以用“&lt;strong&gt;对时间的微分指标 dM/dt&lt;/strong&gt;” 计算得到。例如要计算 RT，就可以使用 &lt;strong&gt;每秒执行时长&lt;/strong&gt; &lt;strong&gt;/&lt;/strong&gt; &lt;strong&gt;每秒查询数&lt;/strong&gt; ，两指标相除即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rate(pg_query_exec_time{}[1m]) / rate(pg_query_calls{}[1m])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;pgss-12.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-12.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dM/dt 可以用于计算 dM/dc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;调用次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 calls 时，对自己微分没有任何意义（结果会恒为 1）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平均延迟/响应时间/RT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 total_exec_time 时，对调用次数求导的结果是 &lt;strong&gt;RT&lt;/strong&gt;，或响应时间/延迟。它的单位是秒（s）。&lt;strong&gt;RT 直接反映了用户体验，是宏观性能分析中最重要的指标&lt;/strong&gt;。这个指标的含义是：此查询组在服务器上的平均查询响应时间。如果条件允许启用 pg_stat_statements.track_planning，还可以加上 total_plan_time 一起计算，结果会更精确更具有代表性。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-13.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-13.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RT：1/5/15 分钟 µ/CV， ±1/3σ分布&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里要特别强调两种特殊情况：第一：PGSS不跟踪失败/执行中的语句；第二：PGSS的统计数据受（pg_stat_statements.max）参数限制，可能出现部分采样偏差。尽管有这些局限性，但想要获取至关重要的查询语句组延迟数据，PGSS 毫无疑问是最为稳妥可靠的来源。正如上面所述，在其他观测点位也有办法采集查询 RT 数据，但会麻烦得多。&lt;/p&gt;
&lt;p&gt;你可以在客户端侧打点，采集语句执行时间，通过指标或者日志上报；你也可以尝试使用 ebpf 来探测语句 RT，这对基础设施和工程师要求会比较高。Pgbouncer 和 PostgreSQL （14+） 倒是也提供了 RT 指标，只可惜粒度都是数据库级别，没有一个能做到 PGSS 查询语句组级别的指标收集。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-14.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-14.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RT：语句级/连接池级/数据库级&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同于 QPS 这样的吞吐量指标，&lt;strong&gt;RT 是具有横向可比性的&lt;/strong&gt;：例如某个查询组平时的 RT 都在1毫秒内，那么超过 10ms 的事件应当被视作严重的偏差进行分析。&lt;/p&gt;
&lt;p&gt;当出现故障时， RT 视图对于定位原因也很有帮助：如果所有查询整体 RT 变慢，那么最有可能与资源不足有关。如果只是特定查询组的 RT 发生变化，那就更有可能是某些慢查询导致了问题，应当进一步调查分析。如果 RT 变化的时间点与应用发布部署吻合，则应当考虑是否要回滚这些部署。&lt;/p&gt;
&lt;p&gt;此外，在性能分析，压力测试，基准测试时，&lt;strong&gt;RT 也是最重要的指标&lt;/strong&gt;。你可以通过对比典型查询在不同环境（例如不同PG大版本、不同硬件、不同配置参数）下的延迟表现来评估系统的性能，并以此为依据不断对系统性能进行调整与改进。&lt;/p&gt;
&lt;p&gt;RT 是如此重要，以至于 RT 本身又会衍生出许多下游指标来：1分钟/5分钟/15分钟的均值µ与标准差σ自然必不可少；过去15分钟的 ±σ，±3σ 可以用来衡量 RT 的波动范围，过去1小时的 95，99 分位点也很有参考价值。&lt;/p&gt;
&lt;p&gt;RT 是评估 OLTP工作负载的核心指标，怎么强调它的重要性都不为过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平均返回行数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 rows 时，我们会得到每次查询&lt;strong&gt;平均返回的行数&lt;/strong&gt;，单位是行/每查询。对于 OLTP 工作负载来说，典型查询模式为点查，即每次查询返回几条数据。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-15.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-15.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按照主键查询单条记录，平均返回行数稳定为1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一个查询组每次查询向客户端吐出几百甚至成千上万行记录，那么应当对其进行审视。如果这是有意而为之的设计，比如批量加载任务/数据转储，那么不需要做什么。如果这是由应用/客户端发起的请求，那么可能存在错误，比如语句缺少 LIMIT 限制，查询缺少分页设计，这样的查询应该进行调整修复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平均共享缓冲区读取/命中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 shared_blks_hit + shared_blks_read 时，我们会得到每条查询“命中”与“读取”共享缓冲区的平均次数，如果将其乘以默认块大小 8KiB，我们就会得到这类查询每次执行的“带宽”，单位是 B/s：每次查询平均会访问/读取多少 MB 数据 ？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-16.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-16.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按照主键查询单条记录，平均返回行数稳定为1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查询平均访问的数据量通常与平均返回的行数相匹配，如果你的查询平均只返回了几行，却访问了成M上G的数据块，那你就需要特别注意了：这样的查询对于数据冷热状态非常敏感，如果所有的块都在缓冲区中，它的性能可能还说的过去，但如果从磁盘冷启动，执行时间可能会出现戏剧性的变化。&lt;/p&gt;
&lt;p&gt;当然，不要忘记 PostgreSQL 双缓存问题，所谓“读取”的数据可能已经在操作系统文件系统层面被缓存过一次了。所以你需要与操作系统监控指标，或者 pg_stat_kcache ，pg_stat_io 这些系统视图相互参照进行分析。&lt;/p&gt;
&lt;p&gt;另一种值得关注的模式是此指标的突变，这通常意味着该查询组的&lt;strong&gt;执行计划可能出现了翻转/劣化&lt;/strong&gt;，非常值得关注与进一步研究。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平均WAL日志量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 M 是 wal_bytes 时，我们得到了每条查询平均生成 WAL 的大小，这是 PostgreSQL 13 新引入的字段。这个指标可以衡量查询的变更足迹大小，并计算读写比例等重要评估参数。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-17.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-17.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;稳定的QPS却有着周期性WAL波动，可推断是 FPI 的影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一个用途是优化检查点/Checkpoint：如果你观察到此指标周期性的起伏（周期约等于 checkpoint_timeout），那么可以通过调整检查点间距，来优化查询产生 WAL 的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对调用次数进行微分的指标 dM/dc&lt;/strong&gt;，可以展现出一类查询的工作负载特性，对于优化用户体验来说非常有用。特别是 RT 乃是性能优化的黄金指标，怎样强调其重要性都不为过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dM/dc&lt;/strong&gt; 这样的指标为我们提供类似重要的绝对值指标，但如果想要找出哪些查询的优化潜在收益最大，还需要用到 &lt;strong&gt;%M 百分比指标&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;百分比指标&#34;&gt;百分比指标&lt;/h2&gt;
&lt;p&gt;现在我们来研究第三类指标，&lt;strong&gt;百分比指标&lt;/strong&gt;。即某个查询组相对于整体工作负载所占的比例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;百分比指标 M%&lt;/strong&gt; 为我们提供了某个查询组相对于整体工作负载的比例，帮助我们在频次、时间、I/O时间/次数上时识别出“主要参与者”，找出潜在优化收益最大的候选查询组，作为优先级评定的重要依据。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-18.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-18.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;常用百分比指标 %M 一览&lt;/p&gt;
&lt;p&gt;举个例子，如果某个查询组有 1000 QPS  的绝对值，看上去不少；但如果它只占整个工作负载的 3%，那么优化此查询的收益与优先级就没那么高了；反之，如果它占据了整个工作负载的 50% 还要多 —— 如果你有办法把它优化掉就可以砍掉整个实例吞吐量的半壁江山，优化它的优先级就会非常之高。&lt;/p&gt;
&lt;p&gt;常见的优化策略是这样的：首先把所有查询组分别按照上面提到的重要指标：calls，total_exec_time，rows，wal_bytes，shared_blks_hit + shared_blks_read，以及 blk_read_time + blk_write_time 在一段时间内的 &lt;strong&gt;dM/dt&lt;/strong&gt; 值进行排序取 TopN （比如 N=10 或者更多），加入优化候选列表中。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-19.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-19.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按照特定标准，选取待优化的 TopSQL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，对于优化候选列表中的每个查询组，依次分析其 &lt;strong&gt;dM/dc&lt;/strong&gt; 指标，结合具体的查询语句与慢查询日志/等待事件进行分析，决定这是不是一个值得优化的查询。对于决定（Plan）进行优化的查询，就可以使用后续篇 &lt;strong&gt;“微观优化”&lt;/strong&gt; 将要介绍的技巧进行调优（Do），并使用监控系统评估优化的效果（Check），总结分析后进入下一个 PDCA 戴明循环，持续进行管理优化。&lt;/p&gt;
&lt;p&gt;除了对指标取 TopN 之外，还可以使用可视化的方式。可视化非常有助于从工作负载中识别 “主要贡献者”，复杂的判断算法可能还远比不上人类DBA对监控图形模式的直觉。想要形成比例感，我们可以借助饼图，树图或者堆叠的时序图。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-20.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-20.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;将所有查询组的 QPS 进行堆叠&lt;/p&gt;
&lt;p&gt;例如，我们可以使用饼图来标识过去1小时内耗时/IO使用最大的查询，使用二维树图（大小代表总耗时，颜色代表平均RT）来展示一个额外的维度。并用堆叠时序图来展示比例随时间的变化关系。&lt;/p&gt;
&lt;p&gt;我们也可以直接分析当下的 PGSS 快照，按照不同的关注点进行排序，按照您自己的标准选择有待优化的查询即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pgss-21.png&#34; src=&#34;/zh/blog/admin/pgss/pgss-21.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;I/O 耗时对于分析查询毛刺原因很有帮助&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;最后，让我们对上面的内容做一个总结。&lt;/p&gt;
&lt;p&gt;PGSS提供了丰富的指标，其中最重要的累积指标可以使用三种方式进行加工处理：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dM/dt&lt;/strong&gt; ：指标 M 基于时间的微分，揭示了&lt;strong&gt;每秒资源使用量&lt;/strong&gt;，通常用于减少资源消耗的优化目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dM/dc&lt;/strong&gt;：指标 M 基于调用次数的微分，揭示了&lt;strong&gt;每次调用的资源使用量&lt;/strong&gt;，通常用于改善用户体验的优化目标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;%M&lt;/strong&gt; ：百分比指标展示了查询组在整个工作负载中所占的百分比，通常用于平衡工作负载的优化目标。&lt;/p&gt;
&lt;p&gt;通常，我们会根据 &lt;strong&gt;%M&lt;/strong&gt; ：百分比指标 Top 查询选择高价值的备选优化查询，并使用 &lt;strong&gt;dM/dt *&lt;em&gt;dM/dc*&lt;/em&gt;&lt;/strong&gt; 指标进行进一步的评估，确认是否有优化空间和可行性，并评估优化后的效果。如此往复，不断循环。&lt;/p&gt;
&lt;p&gt;理解了宏观优化的方法论后，我们就可以用这样的方法去定位优化慢查询了。这里给出了一个具体的 《 &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&amp;mid=2247484478&amp;idx=1&amp;sn=ea44675df79b60a12273e78b358bb557&amp;chksm=fe4b31e5c93cb8f325ba1e4389874112bd5441280492c87e259a32aa67e00c7e0028e7dc51eb&amp;scene=21#wechat_redirect&#34;&gt;利用监控系统诊断PG慢查询&lt;/a&gt;》的例子。在下一篇中，我们将介绍关于 PostgreSQL查询 &lt;strong&gt;微观优化&lt;/strong&gt; 的经验技巧。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; &lt;a href=&#34;https://gitlab.com/postgres-ai/postgresql-consulting/postgres-howtos/&#34;&gt;PostgreSQL HowTO: pg_stat_statements&lt;/a&gt; by Nikolay Samokhvalov&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[2]&lt;/code&gt; &lt;a href=&#34;https://www.postgresql.org/docs/current/pgstatstatements.html&#34;&gt;pg_stat_statements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[3]&lt;/code&gt; &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&amp;mid=2247484478&amp;idx=1&amp;sn=ea44675df79b60a12273e78b358bb557&amp;chksm=fe4b31e5c93cb8f325ba1e4389874112bd5441280492c87e259a32aa67e00c7e0028e7dc51eb&amp;scene=21#wechat_redirect&#34;&gt;利用监控系统诊断PG慢查询&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[4]&lt;/code&gt; &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&amp;mid=2247486169&amp;idx=1&amp;sn=697ab3c172fe6cc28e12cff7297bb343&amp;chksm=fe4b3f02c93cb614bbd1d5075120e074cebb5214d3a1a516363582bcee294e02bf5fd0e051ee&amp;scene=21#wechat_redirect&#34;&gt;如何用Pigsty监控现有PostgreSQL (RDS/PolarDB/自建)？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[5]&lt;/code&gt; &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&amp;mid=2247486283&amp;idx=1&amp;sn=4b63f438df33291a3deb1052bea31347&amp;chksm=fe4b3e90c93cb786a54407a4f7e552b2c8b28478b28df852e41f5d9e2c991761dddbc9a5a813&amp;scene=21#wechat_redirect&#34;&gt;Pigsty v2.5 发布：Ubuntu/Debian支持与监控改版/新扩展&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[6]&lt;/code&gt; &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&amp;mid=2247484189&amp;idx=1&amp;sn=19d4381c7ec4bc4498bd56c5ee9f916b&amp;chksm=fe4b36c6c93cbfd06fba1c7a1ad3c5cba8d0060f82acb56e96f0e64694f79c2df9299f0b1115&amp;scene=21#wechat_redirect&#34;&gt;PostgreSQL监控系统Pigsty概述&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: PostgreSQL 到底有多强？</title>
      <link>/zh/blog/pg/pg-performence/</link>
      <pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>/zh/blog/pg/pg-performence/</guid>
      <description>
        
        
        
        <![CDATA[<img src="/zh/blog/pg/pg-performence/featured_hubaa281b0612be75c10ccedee4459256b_272972_640x0_resize_q75_catmullrom.jpg" width="640" height="640"/>]]>
        
        &lt;p&gt;上回，我们通过分析 StackOverflow 的用户调研数据，说明了《&lt;a href=&#34;/zh/blog//db/pg-is-no1/&#34;&gt;为什么PostgreSQL是最成功的数据库&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;而这一次我们将用性能数据来说话，聊聊最成功的 PostgreSQL 到底有多强，帮助大家做到“&lt;strong&gt;心中有数&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/pg/pg-performence/pg-performence-1.jpg&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;太长不看&#34;&gt;太长不看&lt;/h2&gt;
&lt;p&gt;如果您对以下这些问题有兴趣，那么本文会对您有所帮助：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PostgreSQL 到底性能有多强？
点查 QPS 60万+，最高达 200 万。读写 TPS （4写1读）每秒 7 万+，最高达14万。&lt;/li&gt;
&lt;li&gt;PostgreSQL 与 MySQL 的极限性能对比
极限条件下，PgSQL点查性能显著压倒 MySQL，其他性能基本与MySQL持平。&lt;/li&gt;
&lt;li&gt;PostgreSQL 与其他数据库的性能对比
“分布式数据库”/NewSQL 在相同硬件规格下的性能表现显著落后于经典数据库。&lt;/li&gt;
&lt;li&gt;PostgreSQL 与其他分析数据库的 TPC-H 表现。
PostgreSQL 原生作为一个 HATP 数据库，有比较亮眼的分析表现。&lt;/li&gt;
&lt;li&gt;云数据库 / 云服务器 的成本到底有没有优势？
c5d.metal 用1年的价格，可以把服务器买下来托管用5年。对应规格云数据库用1年的价格，可以供你买同样的EC2用20年&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细测试过程与原始数据放置于：&lt;a href=&#34;https://github.com/Vonng/pgtpc&#34;&gt;github.com/Vonng/pgtpc&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pgbench&#34;&gt;PGBENCH&lt;/h2&gt;
&lt;p&gt;软件与硬件的技术日新月异，尽管性能评测的文章汗牛充栋，却没有多少能反映这些变换。在这项测试中，我们选择了两种新规格硬件，使用 &lt;strong&gt;PGBENCH&lt;/strong&gt; 测试了最新的 PostgreSQL 14.5 在这些硬件上的性能表现。&lt;/p&gt;
&lt;p&gt;测试的主体包括四种规格的硬件，两台 Apple 笔记本与三台 AWS EC2云服务器，分别是 2018 年使用 Intel 6核 i9芯片的 15寸顶配 Macbook Pro，2021 年使用 M1 MAX 芯片的顶配 16 寸 Macbook Pro ，AWS z1d.2xlarge (8C 64G)，以及 AWS c5d.metal ，这些都是市面上可以轻松买到的商用硬件。&lt;/p&gt;
&lt;p&gt;PGBENCH是 PostgreSQL 自带的压测工具，默认使用类 TPC-B 的查询，可用于评估 PostgreSQL 及其兼容版数据库的性能。测试分为两种：只读查询 RO、以及读写 RW。只读查询包含一条 SQL，随机从1亿条数据库中挑选一条查出；而读写事务包含5条SQL语句，一条查询、1条插入与三条更新。测试基于 s=1000 的数据集规模，使用 PGBENCH 逐步增加客户端连接数，找到 QPS / TPS 的极大值点，并记录持续测试 3-5 分钟后的稳定均值，结果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;No&lt;/th&gt;
&lt;th&gt;Spec&lt;/th&gt;
&lt;th&gt;Config&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;Freq&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;th&gt;RO&lt;/th&gt;
&lt;th&gt;RW&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Apple MBP Intel 2018&lt;/td&gt;
&lt;td&gt;Normal&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;2.9GHz - 4.8GHz&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;113870&lt;/td&gt;
&lt;td&gt;15141&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;AWS z1d.2xlarge&lt;/td&gt;
&lt;td&gt;Normal&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;4GHz&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;162315&lt;/td&gt;
&lt;td&gt;24808&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Apple MBP M1 Max 2021&lt;/td&gt;
&lt;td&gt;Normal&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;600MHz - 3.22GHz&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;240841&lt;/td&gt;
&lt;td&gt;31903&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;AWS c5d.metal&lt;/td&gt;
&lt;td&gt;Normal&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;3.6GHz&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;625849&lt;/td&gt;
&lt;td&gt;71624&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;AWS c5d.metal&lt;/td&gt;
&lt;td&gt;Extreme&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;3.6GHz&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;td&gt;1998580&lt;/td&gt;
&lt;td&gt;137127&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;read-write&#34;&gt;&lt;strong&gt;Read Write&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-2.jpg&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-2.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：各硬件配置下读写 TPS 上限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-3.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-3.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：各硬件配置下读写 TPS 曲线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Read Only&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-4.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-4.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：各硬件配置下点查 QPS 上限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-5.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-5.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：各硬件配置下点查 QPS - 并发曲线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果相当令人震惊，在 Apple M1 Max 10C 笔记本上，PG 跑出了 32K 读写，240K 点查的性能水平，在 AWS c5d.metal 生产物理机上，PG 跑出了 72K 读写，630K 点查的性能。使用极限优化压榨，最多可以达到 &lt;strong&gt;单机 137K 读写，2M 点查&lt;/strong&gt; 的怪兽级性能。&lt;/p&gt;
&lt;p&gt;作为一个粗略的规格参考，探探作为一个前部的互联网App，PostgreSQL 全局 TPS 为 40万左右。这意味着十几台这样的新笔记本，或几台顶配服务器（10W内¥）就有潜力支撑起一个大型互联网应用的数据库服务，这对于以前来说是难以想象的。&lt;/p&gt;
&lt;h3 id=&#34;关于成本&#34;&gt;&lt;strong&gt;关于成本&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;以宁夏区域，C5D.METAL 机型为例，该机型是目前综合算力最好的物理机，且自带 3.6 TB的本地NVME SSD存储，有7种可选的付费模式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;付费模式&lt;/th&gt;
&lt;th&gt;月度&lt;/th&gt;
&lt;th&gt;预付&lt;/th&gt;
&lt;th&gt;折合每年&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;按需付费&lt;/td&gt;
&lt;td&gt;31927&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;383,124&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标准预留，1年，无预付费用&lt;/td&gt;
&lt;td&gt;12607&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;151,284&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标准预留，1年，预付部分&lt;/td&gt;
&lt;td&gt;5401&lt;/td&gt;
&lt;td&gt;64,540&lt;/td&gt;
&lt;td&gt;129,352&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标准预留，1年，预付全部费用&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;126,497&lt;/td&gt;
&lt;td&gt;126,497&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可转化预留，3年，无预付费用&lt;/td&gt;
&lt;td&gt;11349&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;136,188&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可转化预留，3年，预付部分&lt;/td&gt;
&lt;td&gt;4863&lt;/td&gt;
&lt;td&gt;174,257&lt;/td&gt;
&lt;td&gt;116,442&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可转化预留，3年，预付全部费用&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;341,543&lt;/td&gt;
&lt;td&gt;113,847&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;折合每年成本在 11万 ～ 15万，零售按需每年成本38万。该机器如果自行购置，IDC托管代维网电五年综合成本应在10万内。尽管看上去云硬件的年化成本高达自建的五倍，但考虑到其灵活性，折扣优惠与抵扣券，AWS EC2 云服务器定价总体仍处于合理范围。使用此类云硬件自建数据库，也有非常优异的性能表现。&lt;/p&gt;
&lt;p&gt;但 RDS for PostgreSQL 则完全是另一个故事了，如果您想使用类似规格的云数据库，最接近的规格是 db.m5.24xlarge，96C，384G，配置 3.6T / 80000 IOPS 的 io1存储（c5d.metal 3.6T NVME SSD 8K RW IOPS 大约95K左右，普通 io1 存储最高 IOPS 为 80K），则每月成本为 24万¥，每年成本为286,7630¥ ，&lt;strong&gt;是同规格 EC2 自建的近 20 倍&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AWS价格计算器：&lt;a href=&#34;https://calculator.amazonaws.cn/&#34;&gt;https://calculator.amazonaws.cn/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sysbench&#34;&gt;SYSBENCH&lt;/h2&gt;
&lt;p&gt;PostgreSQL 确实很强，但与其他数据库系统相比则何如？PGBENCH 主要用于评估 PostgreSQL 及其衍生/兼容数据库的性能，但如果需要横向比较不同数据库的性能表现，我们就要用到 sysbench 了。&lt;/p&gt;
&lt;p&gt;sysbench 是一款开源、跨平台的多线程数据库性能测试工具，测试结果可以很有代表性地反映一个数据库系统的事务处理能力能力。sysbench 包含了10个典型测试用例，如测试点查性能的 &lt;code&gt;oltp_point_select&lt;/code&gt;，更新性能的 &lt;code&gt;oltp_update_index&lt;/code&gt;，综合读写事务性能的 &lt;code&gt;oltp_read_only&lt;/code&gt; (16条查询一个事务)，&lt;code&gt;oltp_read_write&lt;/code&gt; （20条混合查询一个事务）与&lt;code&gt;oltp_write_only&lt;/code&gt; （6条写入SQL）等…。&lt;/p&gt;
&lt;p&gt;sysbench 既可以用于测试 MySQL 的性能，也可以用来测试 PgSQL 的性能（当然也包括两者的兼容衍生），因此具有良好的横向可比性。让我们先来看一下最为喜闻乐见的对比，开源关系数据库内战：世界上“最流行”的开源关系型数据库 —— MySQL ， 与世界上最先进的开源关系型数据库 —— PostgreSQL 性能横向对比。&lt;/p&gt;
&lt;h3 id=&#34;dirty-hack&#34;&gt;&lt;strong&gt;Dirty Hack&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;MySQL 并没有提供一个官方的 sysbench 测试结果，只是在官网上贴出了一个第三方评测结果的图片与链接，不加解释地暗示 MySQL 可以做到 1M 的点查 QPS，240K 的索引键更新，约 39K 的复合读写TPS。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-5.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-6.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：https://www.mysql.com/why-mysql/benchmarks/mysql/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是相当&lt;strong&gt;不讲武德&lt;/strong&gt;的行为。因为如果阅览了连接的评测文章就会发现：这是把所有 MySQL 安全特性关闭得到的结果：关闭Binlog，提交刷盘，FSYNC，性能监控，DoubleWrite，校验和，强制使用 LATIN-1 字符集，这样的数据库根本没法用于生产环境，只是为了刷分而刷分。&lt;/p&gt;
&lt;p&gt;但反过来说，我们也可以使用这些 Dirty Hack，把对应的 PostgreSQL 安全特性也关闭，也看看 PostgreSQL 的最终极限在哪里？结果相当震撼，PGSQL点查QPS干到了 &lt;a href=&#34;/zh/blog//db/pg-performence/&#34;&gt;233万每秒&lt;/a&gt;，峰值远远甩开 MySQL 一倍还多。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-6.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-7.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;图：不讲武德的Benchmark：PgSQL vs MySQL&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-7.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-8.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PostgreSQL 极限配置下点查压测现场&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;必须说明的是，MySQL 的bench使用的是 48C 2.7GHz的机器，而PostgreSQL使用的是 96C 3.6GHz 的机器。不过因为PG使用进程模型，我们可以使用 c=48 的测试值作为 PG 在 48C 机器上表现的一个下限近似：对于只读请求，QPS峰值通常在客户端数略大于CPU核数时达到。即便如此，c=48 时PG的点查 QPS（ 150万）仍然比MySQL峰值高了43%。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在此也期待 MYSQL 专家基于完全相同的硬件给出测评报告，更好的地进行对比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-8.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-9.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：MySQL 有结果的四项 sysbench 结果，c=48&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在其他测试上，MySQL 也有不错的极限表现，&lt;code&gt;otlp_read_only&lt;/code&gt;, &lt;code&gt;oltp_update_non_index&lt;/code&gt; 都与 PostgreSQL （c=48）接近持平，甚至在 &lt;code&gt;oltp_read_write&lt;/code&gt; 上还略微超过 PostgreSQL。&lt;/p&gt;
&lt;p&gt;总体来说在极限条件下，PG除了点查上碾压了MySQL，其他测试上性能与 MySQL 基本持平。&lt;/p&gt;
&lt;h3 id=&#34;fair-play&#34;&gt;&lt;strong&gt;Fair Play&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;尽管在功能丰富度上判若云泥，但 MySQL 在极限性能上基本能与 PostgreSQL 称得上大体旗鼓相当。那么其他的数据库，特别是新一代 NewSQL 的表现又如何呢？&lt;/p&gt;
&lt;p&gt;能够在官网上给出 sysbench 测试报告的数据库都算是 Fair Play 的体面玩家，我们相信他们都是基于真实生产环境使用的配置进行的测试，因此不能和 MySQL 那样使用 Dirty Hack。这里我们依然使用 AWS c5d.metal 机型，但完全使用生产环境配置进行性能测试，相比极限性能有接近一半折损，但更为费厄泼赖，具有很强的可对比性。&lt;/p&gt;
&lt;p&gt;我们从几种比较具有代表性的NewSQL数据库官网上收集到了官方的 sysbench 评测报告。并不是所有的数据库都给出了完整的 sysbench 10 项测试结果，而且硬件规格与表规格也参差不齐。不过考虑到几种数据库均使用基本相仿的硬件规格（100核上下的算力，PolarDB-X , YugaBytes 除外），数据规模也基本为 160M 记录（OB，YB除外），总体还是具有比较可观的横向可比性，也足以让我们管中窥豹形成直觉认知了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Database&lt;/th&gt;
&lt;th&gt;PGSQL.C5D96C&lt;/th&gt;
&lt;th&gt;TiDB.108C&lt;/th&gt;
&lt;th&gt;OceanBase.96C&lt;/th&gt;
&lt;th&gt;PolarX.64C&lt;/th&gt;
&lt;th&gt;Cockroach&lt;/th&gt;
&lt;th&gt;Yugabyte&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;oltp_point_select&lt;/td&gt;
&lt;td&gt;1372654&lt;/td&gt;
&lt;td&gt;407625&lt;/td&gt;
&lt;td&gt;401404&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;336000&lt;/td&gt;
&lt;td&gt;95695&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;oltp_read_only&lt;/td&gt;
&lt;td&gt;852440&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;279067&lt;/td&gt;
&lt;td&gt;366863&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;52416&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;oltp_read_write&lt;/td&gt;
&lt;td&gt;519069&lt;/td&gt;
&lt;td&gt;124460&lt;/td&gt;
&lt;td&gt;157859&lt;/td&gt;
&lt;td&gt;177506&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;9740&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;oltp_write_only&lt;/td&gt;
&lt;td&gt;495942&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;119307&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;9090&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;oltp_delete&lt;/td&gt;
&lt;td&gt;839153&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;67499&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;oltp_insert&lt;/td&gt;
&lt;td&gt;164351&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;112000&lt;/td&gt;
&lt;td&gt;6348&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;oltp_update_non_index&lt;/td&gt;
&lt;td&gt;217626&lt;/td&gt;
&lt;td&gt;62084&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;11496&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;oltp_update_index&lt;/td&gt;
&lt;td&gt;169714&lt;/td&gt;
&lt;td&gt;26431&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4052&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_random_points&lt;/td&gt;
&lt;td&gt;227623&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_random_ranges&lt;/td&gt;
&lt;td&gt;24632&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Machine&lt;/td&gt;
&lt;td&gt;c5d.metal&lt;/td&gt;
&lt;td&gt;m5.xlarge x3 i3.4xlarge x3 c5.4xlarge x3&lt;/td&gt;
&lt;td&gt;ecs.hfg7.8xlarge x3 ecs.hfg7.8xlarge x1&lt;/td&gt;
&lt;td&gt;Enterprise&lt;/td&gt;
&lt;td&gt;c5d.9xlarge x3&lt;/td&gt;
&lt;td&gt;c5.4xlarge x3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spec&lt;/td&gt;
&lt;td&gt;96C 192G&lt;/td&gt;
&lt;td&gt;108C 510G&lt;/td&gt;
&lt;td&gt;96C 384G&lt;/td&gt;
&lt;td&gt;64C 256G&lt;/td&gt;
&lt;td&gt;108C 216G&lt;/td&gt;
&lt;td&gt;48C 96G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Table&lt;/td&gt;
&lt;td&gt;16 x 10M&lt;/td&gt;
&lt;td&gt;16 x 10M&lt;/td&gt;
&lt;td&gt;30 x 10M&lt;/td&gt;
&lt;td&gt;1 x 160M&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;10 x 0.1M&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;108&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;108&lt;/td&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Source&lt;/td&gt;
&lt;td&gt;Vonng&lt;/td&gt;
&lt;td&gt;TiDB 6.1&lt;/td&gt;
&lt;td&gt;OceanBase&lt;/td&gt;
&lt;td&gt;PolarDB&lt;/td&gt;
&lt;td&gt;Cockroach&lt;/td&gt;
&lt;td&gt;YugaByte&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-10.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-10.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：sysbench 10项测试结果（QPS，越高越好）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-11.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-11.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按数据库分类，除以核数的归一化性能对比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让人感到震惊的是，新一代分布式数据库（NewSQL）全线拉胯。在相近的硬件规格下，与 PostgreSQL 表现出高达数量级的差距，几种新数据库中表现最好的反而是仍然基于经典主从架构的 PolarDB。这样的性能结果，&lt;strong&gt;难免不让人重新审视起分布式数据库与 NewSQL 的理念&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通常来说，分布式数据库的核心利弊权衡是质量换规模，但让人没想到的是牺牲掉的不仅仅是功能与稳定性，还有如此可观的性能。高德纳曰：“过早优化是万恶之源”，为了不需要的规模（万亿级+，TP百TB+）牺牲如此大的性能（以及功能与稳定性）毫无疑问是过早优化的一种形式，而能有多少业务场景会有 Google 量级的数据非要分布式数据库不可，仍然是一个问号。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tpc-h分析性能&#34;&gt;TPC-H分析性能&lt;/h2&gt;
&lt;p&gt;TP不行，AP来凑。尽管分布式数据库在 TP 领域如此拉胯，但数据分析 AP 才是分布式数据库的基本盘，因此很多分布式数据库喜欢炒作 HTAP 的概念。而衡量 AP 系统的能力，我们会用到 TPC-H 测试。&lt;/p&gt;
&lt;p&gt;TPC-H 是一个模拟数仓，包含8张数据表，与22条复杂分析类SQL。衡量分析性能的标准通常是在指定仓数下执行这22条SQL的耗时。通常使用100仓，约100GB数据作为基准。我们在本地笔记本和小型AWS云服务器进行了 TPC-H 1,10,50,100 仓的测试，完成全部22个查询，耗时结果如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Scale Factor&lt;/th&gt;
&lt;th&gt;Time (s)&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;Environment&lt;/th&gt;
&lt;th&gt;Comment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10C / 64G&lt;/td&gt;
&lt;td&gt;apple m1 max&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10C / 64G&lt;/td&gt;
&lt;td&gt;apple m1 max&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;1327&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10C / 64G&lt;/td&gt;
&lt;td&gt;apple m1 max&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4835&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10C / 64G&lt;/td&gt;
&lt;td&gt;apple m1 max&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;13.5&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8C / 64G&lt;/td&gt;
&lt;td&gt;z1d.2xlarge&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;133&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8C / 64G&lt;/td&gt;
&lt;td&gt;z1d.2xlarge&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;作为横向对比，我们选取了一些其他数据库官网或比较详细的第三方测评结果。不过在对比前，有几点需要注意：一是有一些数据库产品仓数并非100，二来硬件规格也不尽相同，三来并不是所有数据库评测结果都来自原厂，因此只能作为&lt;strong&gt;大致的对照和参考&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Database&lt;/th&gt;
&lt;th&gt;Time&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;QPH&lt;/th&gt;
&lt;th&gt;Environment&lt;/th&gt;
&lt;th&gt;Source&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;45.0&lt;/td&gt;
&lt;td&gt;10C / 64G M1 Max&lt;/td&gt;
&lt;td&gt;Vonng&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;64.3&lt;/td&gt;
&lt;td&gt;10C / 64G M1 Max&lt;/td&gt;
&lt;td&gt;Vonng&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;1327&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;13.6&lt;/td&gt;
&lt;td&gt;10C / 64G M1 Max&lt;/td&gt;
&lt;td&gt;Vonng&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;4835&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;7.4&lt;/td&gt;
&lt;td&gt;10C / 64G M1 Max&lt;/td&gt;
&lt;td&gt;Vonng&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;13.51&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;33.3&lt;/td&gt;
&lt;td&gt;8C / 64G z1d.2xlarge&lt;/td&gt;
&lt;td&gt;Vonng&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;133.35&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;33.7&lt;/td&gt;
&lt;td&gt;8C / 64G z1d.2xlarge&lt;/td&gt;
&lt;td&gt;Vonng&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TiDB&lt;/td&gt;
&lt;td&gt;190&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;15.8&lt;/td&gt;
&lt;td&gt;120C / 570G&lt;/td&gt;
&lt;td&gt;TiDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spark&lt;/td&gt;
&lt;td&gt;388&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;7.7&lt;/td&gt;
&lt;td&gt;120C / 570G&lt;/td&gt;
&lt;td&gt;TiDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Greenplum&lt;/td&gt;
&lt;td&gt;436&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;288&lt;/td&gt;
&lt;td&gt;2.9&lt;/td&gt;
&lt;td&gt;120C / 570G&lt;/td&gt;
&lt;td&gt;TiDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DeepGreen&lt;/td&gt;
&lt;td&gt;148&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;19.0&lt;/td&gt;
&lt;td&gt;288C / 1152G&lt;/td&gt;
&lt;td&gt;Digoal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MatrixDB&lt;/td&gt;
&lt;td&gt;2306&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;6.1&lt;/td&gt;
&lt;td&gt;256C / 1024G&lt;/td&gt;
&lt;td&gt;MXDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hive&lt;/td&gt;
&lt;td&gt;59599&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;256C / 1024G&lt;/td&gt;
&lt;td&gt;MXDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;StoneDB&lt;/td&gt;
&lt;td&gt;3388&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;1.7&lt;/td&gt;
&lt;td&gt;64C / 128G&lt;/td&gt;
&lt;td&gt;StoneDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ClickHouse&lt;/td&gt;
&lt;td&gt;11537&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;0.5&lt;/td&gt;
&lt;td&gt;64C / 128G&lt;/td&gt;
&lt;td&gt;StoneDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OceanBase&lt;/td&gt;
&lt;td&gt;189&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;19.8&lt;/td&gt;
&lt;td&gt;96C / 384G&lt;/td&gt;
&lt;td&gt;OceanBase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PolarDB&lt;/td&gt;
&lt;td&gt;387&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;14.5&lt;/td&gt;
&lt;td&gt;32C / 128G&lt;/td&gt;
&lt;td&gt;阿里云&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PolarDB&lt;/td&gt;
&lt;td&gt;755&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;14.9&lt;/td&gt;
&lt;td&gt;16C / 64G&lt;/td&gt;
&lt;td&gt;阿里云&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;为了便于衡量，我们可以归一化核数与仓数，用 QPH ，即每小时，每核，执行1仓 TPC-H 查询可以执行多少轮，来近似评估数据库的相对分析性能。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-12.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-12.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;QPH = (1 / 时长) * (仓数 / 核数) * 3600&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;22个查询耗时对于不同仓数来说并非完全线性关系，因此只可作为近似参考。&lt;/p&gt;
&lt;p&gt;不过总体来说，即使是 10 核的笔记本跑 PostgreSQL，也可以有相当亮眼的分析成绩来&lt;/p&gt;
&lt;p&gt;（注：50C以上已经超过内存，走SWAP与磁盘IO了）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-13.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-13.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：论文《how good is my HTAP system》提出的评测 HTAP系统能力的方法 —— 吞吐量前沿，在AP/TP二维平面上画出混合负载的吞吐量极值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至少在百GB级的表上，PostgreSQL足以称得上是一款表现优秀的分析数据库。如果单表超过几TB量级，也可以平滑升级至 Greenplum / MatrixDB / DeepGreen 等 PostgreSQL 兼容MPP数仓。。采用主从复制的 PostgreSQL 可以通过级联从库的方式近乎无限地 Scale 读负载，采用逻辑复制的 PostgreSQL 可以内置/同步地完成AP模式ETL，可谓是真正的 HTAP 数据库。&lt;/p&gt;
&lt;p&gt;综上所述，&lt;strong&gt;PostgreSQL 在 TP 领域表现极其亮眼，在 AP 领域表现可圈可点&lt;/strong&gt;。这也难怪在最近几年的 StackOverflow 开发者年度调研中， PostgreSQL 成为了 专业开发者最常用，最受喜爱，最想要的&lt;a href=&#34;/zh/blog//db/pg-is-no1/&#34;&gt;三冠王数据库&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;pg-performence-14.png&#34; src=&#34;/zh/blog/pg/pg-performence/pg-performence-14.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;StackOverflow 近六年数据库开发者调研结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;[1]  &lt;a href=&#34;https://github.com/Vonng/pgtpc&#34;&gt;Vonng: PGTPC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]  &lt;a href=&#34;https://www.mysql.com/cn/why-mysql/benchmarks/mysql/&#34;&gt;WHY MYSQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]  &lt;a href=&#34;http://dimitrik.free.fr/blog/posts/mysql-performance-1m-iobound-qps-with-80-ga-on-intel-optane-ssd.html&#34;&gt;MySQL Performance : 1M &lt;em&gt;IO-bound&lt;/em&gt; QPS with 8.0 GA on Intel Optane SSD !&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4]  &lt;a href=&#34;http://dimitrik.free.fr/blog/posts/mysql-performance-80-and-sysbench-oltp_rw-updatenokey.html&#34;&gt;MySQL Performance : 8.0 and Sysbench OLTP_RW / Update-NoKEY&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5]  &lt;a href=&#34;http://dimitrik.free.fr/blog/posts/mysql-80-perf-new-dblwr.html&#34;&gt;MySQL Performance : The New InnoDB Double Write Buffer in Action&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6]  &lt;a href=&#34;https://docs.pingcap.com/tidb/stable/benchmark-sysbench-v6.1.0-vs-v6.0.0&#34;&gt;TiDB Sysbench Performance Test Report &amp;ndash; v6.1.0 vs. v6.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7]  &lt;a href=&#34;https://www.oceanbase.com/docs/community/observer-cn/V3.1.4/10000000000450311&#34;&gt;OceanBase 3.1 Sysbench 性能测试报告&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[8]  &lt;a href=&#34;https://www.cockroachlabs.com/docs/stable/performance.html&#34;&gt;Cockroach 22.15 Benchmarking Overview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[9]  &lt;a href=&#34;https://docs.yugabyte.com/preview/benchmark/sysbench-ysql/&#34;&gt;Benchmark YSQL performance using sysbench (v2.15)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[10] &lt;a href=&#34;https://help.aliyun.com/document_detail/139562.html&#34;&gt;PolarDB-X 1.0 Sysbench 测试说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[11] &lt;a href=&#34;https://stonedb.io/zh/docs/performance-tuning/performance-tests/OLAP/tcph-test-report/&#34;&gt;StoneDB OLAP TCP-H测试报告&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[12] &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3514221.3526148&#34;&gt;Elena Milkai: &amp;ldquo;How Good is My HTAP System?&amp;quot;,SIGMOD ’22 Session 25&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[13] &lt;a href=&#34;https://calculator.amazonaws.cn/&#34;&gt;AWS Calculator&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: PG慢查询诊断方法论</title>
      <link>/zh/blog/admin/slow-query/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/zh/blog/admin/slow-query/</guid>
      <description>
        
        
        
        <![CDATA[<img src="/zh/blog/admin/slow-query/featured_hu4d5eeffe411f7f01e98f39eb327d1098_579072_640x0_resize_q75_h2_catmullrom_2.webp" width="640" height="366"/>]]>
        
        &lt;blockquote&gt;
&lt;p&gt;You can&amp;rsquo;t optimize what you can&amp;rsquo;t measure&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;慢查询是在线业务数据库的大敌，如何诊断定位慢查询是DBA的必修课题。&lt;/p&gt;
&lt;p&gt;本文介绍了使用监控系统 —— Pigsty诊断慢查询的一般方法论。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;慢查询危害&#34;&gt;慢查询：危害&lt;/h2&gt;
&lt;p&gt;对于实际服务于在线业务事务处理的PostgreSQL数据库而言，慢查询的危害包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢查询挤占数据库连接，导致普通查询无连接可用，堆积并导致数据库雪崩。&lt;/li&gt;
&lt;li&gt;慢查询长时间锁住了主库已经清理掉的旧版本元组，导致流复制重放进程锁死，导致主从复制延迟。&lt;/li&gt;
&lt;li&gt;查询越慢，查询间相互踩踏的几率越高，越容易产生死锁、锁等待，事务冲突等问题。&lt;/li&gt;
&lt;li&gt;慢查询浪费系统资源，拉高系统水位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，一个合格的DBA必须知道如何及时定位并处理慢查询。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-8.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：一个慢查询优化前后，系统的整体饱和度从40%降到了4%&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;慢查询诊断--传统方法&#34;&gt;慢查询诊断 —— 传统方法&lt;/h2&gt;
&lt;p&gt;传统上来说，在PostgreSQL有两种方式可以获得慢查询的相关信息，一个是通过官方的扩展插件&lt;code&gt;pg_stat_statements&lt;/code&gt;，另一种是慢查询日志。&lt;/p&gt;
&lt;p&gt;慢查询日志顾名思义，所有执行时间长于&lt;code&gt;log_min_duration_statement&lt;/code&gt;参数的查询都会被记录到PG的日志中，对于定位慢查询，特别是&lt;strong&gt;对于分析特例、单次慢查询不可或缺&lt;/strong&gt;。不过慢查询日志也有自己的局限性。在生产环境中出于性能考虑，通常只会记录时长超出某一阈值的查询，那么许多信息就无法从慢查询日志中获取了。当然值得一提的是，尽管开销很大，但&lt;strong&gt;全量查询日志仍然是慢查询分析的终极杀手锏&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;更常用的慢查询诊断工具可能还是&lt;code&gt;pg_stat_statements&lt;/code&gt;。这事是一个非常实用的扩展，它会收集数据库内运行查询的统计信息，&lt;strong&gt;在任何场景下都强烈建议启用该扩展&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pg_stat_statements&lt;/code&gt; 提供的原始指标数据以系统视图表的形式呈现。系统中的&lt;strong&gt;每一类&lt;/strong&gt;查询（即抽取变量后执行计划相同的查询）都分配有一个查询ID，紧接着是调用次数，总耗时，最大、最小、平均单次耗时，响应时间都标准差，每次调用平均返回的行数，用于块IO的时间这些指标类数据。&lt;/p&gt;
&lt;p&gt;一种简单的方式当然是观察 &lt;code&gt;mean_time/max_time&lt;/code&gt;这类指标，从系统的Catalog中，您的确可以知道某类查询有&lt;strong&gt;史以来平均的响应时间&lt;/strong&gt;。对于定位慢查询来说，也许这样也算得上基本够用了。但是像这样的指标，只是系统在当前时刻的一个&lt;strong&gt;静态快照&lt;/strong&gt;，所以能够回答的问题是有限的。譬如说，您想看一看某个查询在加上新索引之后的性能表现是不是有所改善，用这种方式可能就会非常繁琐。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pg_stat_statements&lt;/code&gt;需要在&lt;code&gt;shared_preload_library&lt;/code&gt;中指定，并在数据库中通过&lt;code&gt;CREATE EXTENSION pg_stat_statements&lt;/code&gt;显式创建。创建扩展后即可通过视图&lt;code&gt;pg_stat_statements&lt;/code&gt;访问查询统计信息&lt;/p&gt;
&lt;h3 id=&#34;慢查询的定义&#34;&gt;慢查询的定义&lt;/h3&gt;
&lt;p&gt;多慢的查询算慢查询？&lt;/p&gt;
&lt;p&gt;应该说这个问题&lt;strong&gt;取决于业务&lt;/strong&gt;、以及实际的查询类型，&lt;strong&gt;并没有通用的标准&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;作为一种经验阈值，频繁的CRUD点查，如果超过&lt;strong&gt;1ms&lt;/strong&gt;，可列为慢查询。&lt;/p&gt;
&lt;p&gt;对于偶发的单次特例查询而言，通常超过100ms或1s可以列为慢查询。&lt;/p&gt;
&lt;h2 id=&#34;慢查询诊断--pigsty&#34;&gt;慢查询诊断 —— Pigsty&lt;/h2&gt;
&lt;p&gt;监控系统就可以更全面地回答关于慢查询的问题。监控系统中的数据是由无数&lt;strong&gt;历史快照&lt;/strong&gt;组成的（如5秒一次快照采样）。因此用户可以回溯至任意时间点，考察不同时间段内查询平均响应时间的变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/concept/slow-query.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上图是Pigsty中 &lt;a href=&#34;/zh/docs/pgsql/dasdhboard/&#34;&gt;PG Query Detail&lt;/a&gt;提供的界面，这里展现出了单个查询的详细信息。&lt;/p&gt;
&lt;p&gt;这是一个典型的慢查询，平均响应时间几秒钟。为它添加了一个索引后。从右中Query RT仪表盘的上可以看到，查询的平均响应世界从几秒降到了几毫秒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用户可以利用监控系统提供的&lt;strong&gt;洞察&lt;/strong&gt;迅速定位数据库中的慢查询，定位问题，提出猜想。更重要的是，用户可以&lt;strong&gt;即时地&lt;/strong&gt;在不同层次审视表与查询的详细指标，应用解决方案并获取&lt;strong&gt;实时反馈&lt;/strong&gt;，这对于紧急故障处理是非常有帮助的。&lt;/p&gt;
&lt;p&gt;有时监控系统的用途不仅仅在于提供数据与反馈，它还可以作为一种安抚情绪的良药：设想一个慢查询把生产数据库打雪崩了，如果老板或客户没有一个地方可以透明地知道当前的处理状态，难免会焦急地催问，进一步影响问题解决的速度。监控系统也可以做作为精确管理的依据。您可以有理有据地用监控指标的变化和老板与客户吹牛逼。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一个模拟的慢查询案例&#34;&gt;一个模拟的慢查询案例&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Talk is cheap, show me the code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设用户已经拥有一个 &lt;a href=&#34;/zh/docs/setup/provision/&#34;&gt;Pigsty沙箱演示环境&lt;/a&gt;，下面将使用Pigsty沙箱，演示模拟的慢查询定位与处理流程。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;慢查询模拟&#34;&gt;慢查询：模拟&lt;/h3&gt;
&lt;p&gt;因为没有实际的业务系统，这里我们以一种简单快捷的方式模拟系统中的慢查询。即&lt;code&gt;pgbench&lt;/code&gt;自带的类&lt;code&gt;tpc-b&lt;/code&gt;场景。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;make ri / make ro / make rw&lt;/code&gt;，在&lt;code&gt;pg-test&lt;/code&gt;集群上初始化 pgbench 用例，并对集群施加读写负载&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 50TPS 写入负载&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;while&lt;/span&gt; true&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;do&lt;/span&gt; pgbench -nv -P1 -c20 --rate&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;50&lt;/span&gt; -T10 postgres://test:test@pg-test:5433/test&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 1000TPS 只读负载&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;while&lt;/span&gt; true&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;do&lt;/span&gt; pgbench -nv -P1 -c40 --select-only --rate&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1000&lt;/span&gt; -T10 postgres://test:test@pg-test:5434/test&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在我们已经有了一个模拟运行中的业务系统，让我们通过简单粗暴的方式来模拟一个慢查询场景。在&lt;code&gt;pg-test&lt;/code&gt;集群的主库上执行以下命令，删除表&lt;code&gt;pgbench_accounts&lt;/code&gt;的主键：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ALTER&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;TABLE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;pgbench_accounts&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;DROP&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CONSTRAINT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;pgbench_accounts_pkey&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该命令会移除 &lt;code&gt;pgbench_accounts&lt;/code&gt; 表上的主键，导致&lt;strong&gt;相关查询&lt;/strong&gt;从索引扫描变为顺序全表扫描，全部变为慢查询，访问&lt;a href=&#34;/zh/zh/docs/pgsql/dasdhboard&#34;&gt;PG Instance&lt;/a&gt; ➡️ Query ➡️ QPS，结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-1.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图1：平均查询响应时间从1ms飙升为300ms，单个从库实例的QPS从500下降至7。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与此同时，实例因为慢查询堆积，系统会在瞬间&lt;strong&gt;雪崩过载&lt;/strong&gt;，访问&lt;a href=&#34;/zh/zh/docs/pgsql/dasdhboard&#34;&gt;PG Cluster&lt;/a&gt;首页，可以看到集群负载出现飙升。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-2.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图2：系统负载达到200%，触发机器负载过大，与查询响应时间过长的报警规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;慢查询定位&#34;&gt;慢查询：定位&lt;/h3&gt;
&lt;p&gt;首先，使用&lt;a href=&#34;/zh/zh/docs/pgsql/dasdhboard&#34;&gt;PG Cluster&lt;/a&gt;面板定位慢查询所在的具体实例，这里以 &lt;code&gt;pg-test-2&lt;/code&gt; 为例。&lt;/p&gt;
&lt;p&gt;然后，使用&lt;a href=&#34;/zh/zh/docs/pgsql/dasdhboard&#34;&gt;PG Query&lt;/a&gt;面板定位具体的慢查询：编号为 &lt;strong&gt;-6041100154778468427&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-3.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图3：从查询总览中发现异常慢查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该查询表现出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应时间显著上升： 17us 升至 280ms&lt;/li&gt;
&lt;li&gt;QPS 显著下降：       从500下降到 7&lt;/li&gt;
&lt;li&gt;花费在该查询上的时间占比显著增加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以确定，就是这个查询变慢了！&lt;/p&gt;
&lt;p&gt;接下来，利用&lt;a href=&#34;/zh/zh/docs/pgsql/dasdhboard/&#34;&gt;PG Stat Statements&lt;/a&gt;面板或&lt;a href=&#34;/zh/zh/docs/pgsql/dasdhboard&#34;&gt;PG Query Detail&lt;/a&gt;，根据查询ID定位慢查询的&lt;strong&gt;具体语句&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-4.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图4：定位查询语句为&lt;code&gt;SELECT abalance FROM pgbench_accounts WHERE aid = $1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;慢查询猜想&#34;&gt;慢查询：猜想&lt;/h3&gt;
&lt;p&gt;获知慢查询语句后，接下来需要推断慢查询&lt;strong&gt;产生的原因&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;SELECT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;abalance&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;pgbench_accounts&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;WHERE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;aid&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a40000&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该查询以 &lt;code&gt;aid&lt;/code&gt; 作为过滤条件查询 &lt;code&gt;pgbench_accounts&lt;/code&gt; 表，如此简单的查询变慢，大概率是这张表上的索引出了问题。 &lt;em&gt;用屁股想都知道是索引少了，因为就是我们自己删掉的嘛！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;分析查询后， 可以&lt;strong&gt;提出猜想&lt;/strong&gt;： 该查询变慢是&lt;code&gt;pgbench_accounts&lt;/code&gt;表上&lt;code&gt;aid&lt;/code&gt;列缺少索引。&lt;/p&gt;
&lt;p&gt;下一步，我们就要&lt;strong&gt;验证猜想&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第一步，使用&lt;a href=&#34;/zh/zh/docs/pgsql/dasdhboard&#34;&gt;PG Table Catalog&lt;/a&gt;，我们可以检视表的详情，例如表上建立的索引。&lt;/p&gt;
&lt;p&gt;第二步，查阅 &lt;a href=&#34;/zh/zh/docs/pgsql/dasdhboard&#34;&gt;PG Table Detail&lt;/a&gt; 面板，检查 &lt;code&gt;pgbench_accounts&lt;/code&gt; 表上的访问，来验证我们的猜想&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-5.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图5： &lt;code&gt;pgbench_accounts&lt;/code&gt; 表上的访问情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过观察，我们发现表上的&lt;strong&gt;索引扫描&lt;/strong&gt;归零，与此同时&lt;strong&gt;顺序扫描&lt;/strong&gt;却有相应增长。这印证了我们的猜想！&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;慢查询方案&#34;&gt;慢查询：方案&lt;/h3&gt;
&lt;p&gt;假设一旦成立，就可以着手提出方案，解决问题了。&lt;/p&gt;
&lt;p&gt;解决慢查询通常有三种方式：&lt;strong&gt;修改表结构&lt;/strong&gt;、&lt;strong&gt;修改查询&lt;/strong&gt;、&lt;strong&gt;修改索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;修改表结构与查询通常涉及到具体的业务知识和领域知识，需要具体问题具体分析。但修改索引通常来说不需要太多的具体业务知识。&lt;/p&gt;
&lt;p&gt;这里的问题可以通过添加索引解决，&lt;code&gt;pgbench_accounts&lt;/code&gt; 表上 &lt;code&gt;aid&lt;/code&gt; 列缺少索引，那么我们尝试在 &lt;code&gt;pgbench_accounts&lt;/code&gt; 表上为 &lt;code&gt;aid&lt;/code&gt; 列添加索引，看看能否解决这个问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UNIQUE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;INDEX&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;pgbench_accounts&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;aid&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;加上索引后，神奇的事情发生了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-6.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图6：可以看到，查询的响应时间与QPS已经恢复正常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-7.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图7：系统的负载也恢复正常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;慢查询评估&#34;&gt;慢查询：评估&lt;/h3&gt;
&lt;p&gt;作为慢查询处理的最后一步，我们通常需要对操作的过程进行记录，对效果进行评估。&lt;/p&gt;
&lt;p&gt;有时候一个简单的优化可以产生戏剧性的效果。也许本来需要砸几十万加机器的问题，创建一个索引就解决了。&lt;/p&gt;
&lt;p&gt;这种故事，就可以通过监控系统，用很生动直观的形式表达出来，赚取KPI与Credit。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/zh/blog/admin/slow-query/slow-query-8.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图：一个慢查询优化前后，系统的整体饱和度从40%降到了4%&lt;/p&gt;
&lt;p&gt;（相当于节省了X台机器，XX万元，老板看了心花怒放，下一任CTO就是你了！）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;慢查询小结&#34;&gt;慢查询：小结&lt;/h3&gt;
&lt;p&gt;通过这篇教程，您已经掌握了慢查询优化的一般方法论。即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定位问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提出猜想&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证假设&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;制定方案&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评估效果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;监控系统在慢查询处理的整个生命周期中都能起到重要的效果。更能将运维与DBA的“经验”与“成果”，以可视化，可量化，可复制的方式表达出来。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: 使用FIO测试磁盘性能</title>
      <link>/zh/blog/admin/fio/</link>
      <pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/zh/blog/admin/fio/</guid>
      <description>
        
        
        &lt;p&gt;Fio是一个很好用的磁盘性能测试工具，可以通过以下命令测试磁盘的读写性能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fio --filename&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/tmp/fio.data &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -direct&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -iodepth&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -rw&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;randrw &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    --rwmixread&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;80&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -bs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;4k &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1G &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -numjobs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -runtime&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;60&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -group_reporting &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    -name&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;randrw &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    --output&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/tmp/fio_randomrw.txt &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; unlink /tmp/fio.data
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是常用的测试组合，确保 &lt;code&gt;/data/&lt;/code&gt; 挂载了数据盘&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--8k  随机写
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fio -name&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;8krandw  -runtime&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;120&lt;/span&gt;  -filename&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/data/rand.txt -ioengine&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;libaio -direct&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -bs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;8K  -size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;10g  -iodepth&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;128&lt;/span&gt;  -numjobs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -rw&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;randwrite -group_reporting -time_based
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--8K  随机读
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fio -name&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;8krandr  -runtime&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;120&lt;/span&gt;  -filename&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/data/rand.txt -ioengine&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;libaio -direct&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -bs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;8K  -size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;10g  -iodepth&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;128&lt;/span&gt;  -numjobs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -rw&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;randread -group_reporting -time_based
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--8k  混合读写
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fio -name&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;8krandrw  -runtime&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;120&lt;/span&gt;  -filename&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/data/rand.txt -ioengine&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;libaio -direct&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -bs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;8k  -size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;10g  -iodepth&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;128&lt;/span&gt;  -numjobs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -rw&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;randrw -rwmixwrite&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;30&lt;/span&gt;  -group_reporting -time_based
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--1Mb  顺序写
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fio -name&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1mseqw  -runtime&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;120&lt;/span&gt;  -filename&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/data/seq.txt -ioengine&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;libaio -direct&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -bs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1024k  -size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;20g  -iodepth&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;128&lt;/span&gt;  -numjobs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -rw&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;write -group_reporting -time_based
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--1Mb  顺序读
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fio -name&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1mseqr  -runtime&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;120&lt;/span&gt;  -filename&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/data/seq.txt -ioengine&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;libaio -direct&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -bs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1024k  -size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;20g  -iodepth&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;128&lt;/span&gt;  -numjobs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -rw&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;read&lt;/span&gt; -group_reporting -time_based
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;--1Mb  顺序读写
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fio -name&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1mseqrw  -runtime&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;120&lt;/span&gt;  -filename&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;/data/seq.txt -ioengine&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;libaio -direct&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -bs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;1024k  -size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;20g  -iodepth&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;128&lt;/span&gt;  -numjobs&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;  -rw&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;rw -rwmixwrite&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;30&lt;/span&gt;  -group_reporting -time_based
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;测试 PostgreSQL 相关的 IO 性能表现时，应当主要以 8KB 随机IO为主，可以考虑以下参数组合。&lt;/p&gt;
&lt;p&gt;3个维度：RW Ratio, Block Size, N Jobs 进行排列组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RW Ratio:  Pure Read, Pure Write, rwmixwrite=80, rwmixwrite=20&lt;/li&gt;
&lt;li&gt;Block Size = 4KB (OS granular), 8KB (DB granular)&lt;/li&gt;
&lt;li&gt;N jobs: 1 , 4 , 8 , 16 ,32&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: 使用sysbench测试PostgreSQL性能</title>
      <link>/zh/blog/admin/sysbench/</link>
      <pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/zh/blog/admin/sysbench/</guid>
      <description>
        
        
        &lt;p&gt;sysbench首页：https://github.com/akopytov/sysbench&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;二进制安装，在Mac上，使用brew安装sysbench。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install sysbench --with-postgresql
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;源代码编译（CentOS）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum -y install make automake libtool pkgconfig libaio-devel
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# For MySQL support, replace with mysql-devel on RHEL/CentOS 5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum -y install mariadb-devel openssl-devel
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# For PostgreSQL support&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;yum -y install postgresql-devel
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;源代码编译&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install automake libtool openssl pkg-config
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# For MySQL support&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install mysql
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# For PostgreSQL support&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install postgresql
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# openssl is not linked by Homebrew, this is to avoid &amp;#34;ld: library not found for -lssl&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LDFLAGS&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;-L/usr/local/opt/openssl/lib 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./autogen.sh
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# --with-pgsql --with-pgsql-libs --with-pgsql-includes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# -- without-mysql&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./configure 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make -j
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make install
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;
&lt;p&gt;创建一个压测用PostgreSQL数据库：&lt;code&gt;bench&lt;/code&gt;，初始化测试用数据库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sysbench /usr/local/share/sysbench/oltp_read_write.lua &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--db-driver&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;pgsql &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--pgsql-host&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;127.0.0.1 &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--pgsql-port&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;5432&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--pgsql-user&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;vonng &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--pgsql-db&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;bench &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--table_size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;100000&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--tables&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	prepare
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Creating table &amp;#39;sbtest1&amp;#39;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Inserting 100000 records into &amp;#39;sbtest1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Creating a secondary index on &amp;#39;sbtest1&amp;#39;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Creating table &amp;#39;sbtest2&amp;#39;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Inserting 100000 records into &amp;#39;sbtest2&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Creating a secondary index on &amp;#39;sbtest2&amp;#39;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Creating table &amp;#39;sbtest3&amp;#39;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Inserting 100000 records into &amp;#39;sbtest3&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Creating a secondary index on &amp;#39;sbtest3&amp;#39;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;压测&#34;&gt;压测&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sysbench /usr/local/share/sysbench/oltp_read_write.lua &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--db-driver&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;pgsql &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--pgsql-host&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;127.0.0.1 &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--pgsql-port&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;5432&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--pgsql-user&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;vonng &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--pgsql-db&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;bench &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;	--table_size&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;100000&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    --tables&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    --threads&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    --time&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;    run
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sysbench 1.1.0-e6e6a02 (using bundled LuaJIT 2.1.0-beta3)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Running the test with following options:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Number of threads: 4
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Initializing random number generator from current time
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Initializing worker threads...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Threads started!
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SQL statistics:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    queries performed:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        read:                            127862
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        write:                           36526
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        other:                           18268
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        total:                           182656
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    transactions:                        9131   (760.56 per sec.)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    queries:                             182656 (15214.20 per sec.)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ignored errors:                      2      (0.17 per sec.)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    reconnects:                          0      (0.00 per sec.)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Throughput:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    events/s (eps):                      760.5600
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    time elapsed:                        12.0056s
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    total number of events:              9131
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Latency (ms):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         min:                                    4.30
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         avg:                                    5.26
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         max:                                   15.20
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         95th percentile:                        5.99
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         sum:                                47995.39
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Threads fairness:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    events (avg/stddev):           2282.7500/4.02
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    execution time (avg/stddev):   11.9988/0.00
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
  </channel>
</rss>
