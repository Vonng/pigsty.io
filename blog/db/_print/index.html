<!doctype html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="canonical" type="text/html" href="/blog/db/">
<link rel="alternate" type="application/rss&#43;xml" href="/blog/db/index.xml">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/favicons/android-192x192.png" sizes="192x192">

<title>Database | Pigsty</title>
<meta name="description" content="Articles about database industry, surveys, methods, ideas and best practices">
<meta property="og:title" content="Database" />
<meta property="og:description" content="Articles about database industry, surveys, methods, ideas and best practices" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/blog/db/" />

<meta itemprop="name" content="Database">
<meta itemprop="description" content="Articles about database industry, surveys, methods, ideas and best practices"><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Database"/>
<meta name="twitter:description" content="Articles about database industry, surveys, methods, ideas and best practices"/>




<link rel="preload" href="/scss/main.min.194607c777ee31a481a26dfc3d1c65134dfc8eb296a0aae9d353b3bd5be6a683.css" as="style">
<link href="/scss/main.min.194607c777ee31a481a26dfc3d1c65134dfc8eb296a0aae9d353b3bd5be6a683.css" rel="stylesheet" integrity="">

<script
  src="/js/jquery-3.6.3.min.js"
  integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ=="
  crossorigin="anonymous"></script>
<script defer
  src="/js/lunr.min.js"
  integrity="sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli"
  crossorigin="anonymous"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LG1V9WTKGE"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-LG1V9WTKGE');
}
</script>
  </head>
  <body class="td-section td-blog">
    <header>
      <nav class="td-navbar navbar-dark js-navbar-scroll">
<div class="container-fluid flex-column flex-md-row">
  <a class="navbar-brand" href="/"><span class="navbar-brand__logo navbar-logo"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xl="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 24 24" width="24" height="24"><defs/><g id="32" fill="none" stroke-dasharray="none" fill-opacity="1" stroke-opacity="1" stroke="none"><title>32</title><g id="32_图层_2"><title>图层 2</title><g id="Group_17"><g id="Graphic_16"/><g id="Graphic_15"><path d="M7.666187 11.971335l2.165064-3.75H14.16138l2.165065 3.75-2.165065 3.75H9.831251z" fill="#bbb" fill-opacity=".9526367"/><path d="M7.666187 11.971335l2.165064-3.75H14.16138l2.165065 3.75-2.165065 3.75H9.831251z" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width=".6730434"/></g><g id="Graphic_14"><path d="M7.666187 19.474806l2.165064-3.75H14.16138l2.165065 3.75-2.165065 3.75H9.831251z" fill="#de372c" fill-opacity=".8545852"/><path d="M7.666187 19.474806l2.165064-3.75H14.16138l2.165065 3.75-2.165065 3.75H9.831251z" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width=".6730434"/></g><g id="Graphic_13"><path d="M14.161476 15.751202l2.165064-3.75h4.33013l2.165064 3.75-2.165064 3.75H16.32654z" fill="#424242" fill-opacity=".9016462"/><path d="M14.161476 15.751202l2.165064-3.75h4.33013l2.165064 3.75-2.165064 3.75H16.32654z" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width=".6730434"/></g><g id="Graphic_12"><path d="M14.161476 8.226008 16.32654 4.4760076h4.33013L22.821734 8.226008l-2.165064 3.75H16.32654z" fill="#ffa269" fill-opacity=".8975772"/><path d="M14.161476 8.226008 16.32654 4.4760076h4.33013L22.821734 8.226008l-2.165064 3.75H16.32654z" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width=".6730434"/></g><g id="Graphic_11"><path d="M7.666187 4.5 9.831251.75H14.16138L16.326445 4.5 14.16138 8.25H9.831251z" fill="#419edb" fill-opacity=".8979957"/><path d="M7.666187 4.5 9.831251.75H14.16138L16.326445 4.5 14.16138 8.25H9.831251z" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width=".6730434"/></g><g id="Graphic_10"><path d="M1.1491742 8.226008 3.3142388 4.4760076H7.644368L9.809432 8.226008l-2.165064 3.75H3.3142388z" fill="#2f6793" fill-opacity=".9002511"/><path d="M1.1491742 8.226008 3.3142388 4.4760076H7.644368L9.809432 8.226008l-2.165064 3.75H3.3142388z" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width=".6730434"/></g><g id="Graphic_9"><path d="M1.182071 15.741036l2.1650645-3.75h4.330129l2.1650645 3.75-2.1650645 3.75H3.3471355z" fill="#53ac79" fill-opacity=".9"/><path d="M1.182071 15.741036l2.1650645-3.75h4.330129l2.1650645 3.75-2.1650645 3.75H3.3471355z" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width=".6730434"/></g></g></g></g></svg></span><span class="navbar-brand__name">Pigsty</span></a>
  <div class="td-navbar-nav-scroll ms-md-auto" id="main_navbar">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link" href="/docs/"><i class='fa-solid fa-book'></i><span>Docs</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link active" href="/blog/"><i class="fas fa-blog"></i><span>Blog</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="https://github.com/Vonng/pigsty/" target="_blank" rel="noopener"><i class='fab fa-github'></i><span>GitHub</span></a>
      </li>
      <li class="nav-item dropdown d-none d-lg-block">
        <div class="dropdown">
  <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Link</a>
  <ul class="dropdown-menu">
    <li><a class="dropdown-item" href="/docs/">v3 Docs</a></li>
    <li><a class="dropdown-item" href="https://demo.pigsty.cc">Public Demo</a></li>
    <li><a class="dropdown-item" href="https://ext.pigsty.io">Extension Repo</a></li>
    <li><a class="dropdown-item" href="https://pigsty.cc/zh/docs">pigsty.cc</a></li>
    <li><a class="dropdown-item" href="https://pigsty.cc/zh/blog">ZH Blog</a></li>
    </ul>
</div></li>
      <li class="nav-item dropdown d-none d-lg-block">
        <div class="dropdown">
  <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
      <i class="fa-solid fa-language"></i>English</a>
  <ul class="dropdown-menu">
    <li><a class="dropdown-item" href="/zh/blog/db/">中文</a></li>
    </ul>
</div>
</li>
      </ul>
  </div>
  <div class="d-none d-lg-block">
    <div class="td-search td-search--offline">
  <div class="td-search__icon"></div>
  <input
    type="search"
    class="td-search__input form-control"
    placeholder="Search this site…"
    aria-label="Search this site…"
    autocomplete="off"
    
    data-offline-search-index-json-src="/offline-search-index.e20cef2c1fb59d65c1649f8d99b8930d.json"
    data-offline-search-base-href="/"
    data-offline-search-max-results="10"
  >
</div>
  </div>
</div>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
          </div>
          <main class="col-12 col-md-9 col-xl-8 ps-md-5 pe-md-4" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This is the multi-page printable view of this section.
<a href="#" onclick="print();return false;">Click here to print</a>.
</p><p>
<a href="/blog/db/">Return to the regular view of this page</a>.
</p>
</div>



<h1 class="title">Database</h1>
<div class="lead">Articles about database industry, surveys, methods, ideas and best practices</div>




    <ul>
    
  
  
  
  

  
    
    
	

    <li><a href="#pg-3085215d905f9975fefe74e9dc129cba">Database in K8S: Pros &amp; Cons</a></li>



    
  
    
    
	

    <li><a href="#pg-564f2bc59ef0064fb9b5b78f3ee282ef">NewSQL: Distributive Nonsens</a></li>



    
  
    
    
	

    <li><a href="#pg-65bb532e2949268a0bd020d4878070be">Is running postgres in docker a good idea?</a></li>



    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    


  

<div class="td-content" style="">
    <h1 id="pg-3085215d905f9975fefe74e9dc129cba">Database in K8S: Pros &amp; Cons</h1>
	
	<div class="td-byline mb-4">
		By <b><a href="https://vonng.com/en/">Ruohang Feng</a> (<a href="https://vonng.com/en/">@Vonng</a>) | <a href="https://medium.com/@fengruohang/database-in-kubernetes-is-that-a-good-idea-daf5775b5c1f">Medium</a> ｜<a href="https://mp.weixin.qq.com/s/4a8Qy4O80xqsnytC4l9lRg">Wechat</a></b> |
        
		<time datetime="2023-12-06" class="text-muted">2023-12-06</time>
        
	</div>
	<p>Whether databases should be housed in Kubernetes/Docker remains highly controversial. While Kubernetes (k8s) excels in managing stateless applications, it has fundamental drawbacks with stateful services, especially databases like PostgreSQL and MySQL.</p>
<p>In the previous article, &ldquo;<a href="/blog/db/pg-in-docker/">Databases in Docker: Good or Bad</a>,&rdquo; we discussed the pros and cons of containerizing databases. Today, let&rsquo;s delve into the trade-offs in orchestrating databases in K8S and explore why it&rsquo;s not a wise decision.</p>
<hr>
<h2 id="summary">Summary</h2>
<p>Kubernetes (k8s) is an exceptional container orchestration tool aimed at helping developers better manage a vast array of complex stateless applications. Despite its offerings like StatefulSet, PV, PVC, and LocalhostPV for supporting stateful services (i.e., databases), these features are still insufficient for running production-level databases that demand higher reliability.</p>
<p>Databases are more like &ldquo;<strong>pets</strong>&rdquo; than &ldquo;<strong>cattle</strong>&rdquo; and require careful nurturing. Treating databases as &ldquo;cattle&rdquo; in K8S essentially turns external disk/file system/storage services into new &ldquo;database pets.&rdquo; Running databases on EBS/network storage presents significant disadvantages in reliability and performance. However, using high-performance local NVMe disks will make the database bound to nodes and non-schedulable, negating the primary purpose of putting them in K8S.</p>
<p>Placing databases in K8S results in a <strong>&ldquo;lose-lose&rdquo;</strong> situation - K8S loses its simplicity in statelessness, lacking the flexibility to quickly relocate, schedule, destroy, and rebuild like purely stateless use. On the other hand, databases suffer several crucial attributes: reliability, security, performance, and complexity costs, in exchange for limited &ldquo;elasticity&rdquo; and utilization - something virtual machines can also achieve. For users outside public cloud vendors, the disadvantages far outweigh the benefits.</p>
<p>The &ldquo;<strong>cloud-native frenzy</strong>,&rdquo; exemplified by K8S, has become a distorted phenomenon: adopting k8s for the sake of k8s. Engineers add extra complexity to increase their irreplaceability, while managers fear being left behind by the industry and getting caught up in deployment races. Using tanks for tasks that could be done with bicycles, to gain experience or prove oneself, without considering if the problem needs such &ldquo;dragon-slaying&rdquo; techniques - this kind of architectural juggling will eventually lead to adverse outcomes.</p>
<p>Until the reliability and performance of the network storage surpass local storage, placing databases in K8S is an unwise choice. There are other ways to seal the complexity of database management, such as RDS and open-source RDS solutions like <a href="http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&mid=2247485518&idx=1&sn=3d5f3c753facc829b2300a15df50d237&chksm=fe4b3d95c93cb4833b8e80433cff46a893f939154be60a2a24ee96598f96b32271301abfda1f&scene=21#wechat_redirect"><strong>Pigsty</strong></a>, which are based on bare Metal or bare OS. Users should make wise decisions based on their situations and needs, carefully weighing the pros and cons.</p>
<hr>
<h2 id="the-status-quo">The Status Quo</h2>
<p>K8S excels in orchestrating stateless application services but was initially limited to stateful services. Despite not being the intended purpose of K8S and Docker, the community&rsquo;s zeal for expansion has been unstoppable. Evangelists depict K8S as the next-generation cloud operating system, asserting that databases will inevitably become regular applications within Kubernetes. Various abstractions have emerged to support stateful services: StatefulSet, PV, PVC, and LocalhostPV.</p>
<p>Countless cloud-native enthusiasts have attempted to migrate existing databases into K8S, resulting in a proliferation of CRDs and Operators for databases. Taking PostgreSQL as an example, there are already more than ten different K8S deployment solutions available: PGO, StackGres, CloudNativePG, PostgresOperator, PerconaOperator, CYBERTEC-pg-operator, TemboOperator,  Kubegres, KubeDB, KubeBlocks, and so on. The CNCF landscape rapidly expands, turning into a playground of complexity.</p>
<p>However, complexity is a cost. With &ldquo;cost reduction&rdquo; becoming mainstream, voices of reflection have begun to emerge. Could-Exit Pioneers like DHH, who deeply utilized K8S in public clouds, abandoned it due to its excessive complexity during the transition to <a href="https://mp.weixin.qq.com/s/CicctyvV1xk5B-AsKfzPjw">self-hosted open-source solutions</a>, relying only on Docker and a Ruby tool named Kamal as alternatives. Many began to question whether stateful services like databases suit Kubernetes.</p>
<p>K8S itself, in its effort to support stateful applications, has become increasingly complex, straying from its original intention as a container orchestration platform. Tim Hockin, a co-founder of Kubernetes, also voiced his rare concerns at this year&rsquo;s KubeCon in <a href="https://mp.weixin.qq.com/s/9Q9kze9D2LT0-G2lXSvADg">&ldquo;K8s is Cannibalizing Itself!&rdquo;</a>: &ldquo;<em><strong>Kubernetes has become too complex; it needs to learn restraint, or it will stop innovating and lose its base</strong></em>.&rdquo;</p>
<hr>
<h2 id="lose-lose-situation">Lose-Lose Situation</h2>
<p>In the cloud-native realm, the analogy of &ldquo;pets&rdquo; versus &ldquo;cattle&rdquo; is often used for illustrating stateful services. &ldquo;Pets,&rdquo; like databases, need careful and individual care, while &ldquo;cattle&rdquo; represent disposable, stateless applications (Disposability).</p>
<figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 778px">
<img class="card-img-top" src="/zh/blog/db/db-in-k8s/12-factor_hue92b117bbc262aa2b08fc07fefd75e09_483297_768x384_fit_catmullrom_3.png" width="768" height="379">
<figcaption class="card-body px-0 pt-2 pb-0">
<p class="card-text">
<p>Cloud Native Applications 12 Factors: <strong>Disposability</strong>
<small class="text-muted"><br/><em>source</em>: <a href="https://user-images.githubusercontent.com/5445356/47986421-a8f62080-e117-11e8-9a39-3fdc6030c324.png">https://user-images.githubusercontent.com/5445356/47986421-a8f62080-e117-11e8-9a39-3fdc6030c324.png</a></small></p>
</p>
</figcaption>
</figure>
<blockquote>
<p>Cloud Native Applications 12 Factors: <strong>Disposability</strong></p>
</blockquote>
<p>One of the leading architectural goals of K8S is to <strong>treat what can be treated as cattle as cattle</strong>. The attempt to &ldquo;separate storage from computation&rdquo; in databases follows this strategy: splitting stateful database services into state storage outside K8S and pure computation inside K8S. The state is stored on the EBS/cloud disk/distributed storage service, allowing the &ldquo;stateless&rdquo; database part to be freely created, destroyed, and scheduled in K8S.</p>
<p>Unfortunately, databases, especially OLTP databases, heavily depend on disk hardware, and network storage&rsquo;s reliability and performance still lag behind local disks by <a href="https://mp.weixin.qq.com/s/UxjiUBTpb1pRUfGtR9V3ag">orders of magnitude</a>. Thus, K8S offers the LocalhostPV option, allowing containers to use data volumes directly lies on the host operating system, utilizing high-performance/high-reliability local NVMe disk storage.</p>
<p>However, this presents a dilemma: should one use subpar cloud disks and tolerate poor database reliability/performance for K8S&rsquo;s scheduling and orchestration capabilities? Or use high-performance local disks tied to host nodes, virtually losing all flexible scheduling abilities? The former is like stuffing an anchor into K8S&rsquo;s small boat, slowing overall speed and agility; the latter is like anchoring and pinning the ship to a specific point.</p>
<p>Running a stateless K8S cluster is simple and reliable, as is running a stateful database on a physical machine&rsquo;s bare operating system. Mixing the two, however, results in a <strong>lose-lose situation</strong>: <em><strong>K8S loses its stateless flexibility and casual scheduling abilities, while the database sacrifices core attributes like reliability, security, efficiency, and simplicity in exchange for elasticity, resource utilization, and Day1 delivery speed that are not fundamentally important to databases</strong></em>.</p>
<p>A vivid example of the former is the performance optimization of <a href="https://mp.weixin.qq.com/s/SCImfwEvkCPqZhLGx758Sw">PostgreSQL@K8S</a>, which KubeBlocks contributed. K8S experts employed various advanced methods to solve performance issues that did not exist on bare metal/bare OS at all. A fresh case of the latter is Didi&rsquo;s <a href="https://mp.weixin.qq.com/s/FIOB_Oqefx1oez1iu7AGGg">K8S architecture juggling disaster</a>; if it weren&rsquo;t for putting the stateful MySQL in K8S, would rebuilding a stateless K8S cluster and redeploying applications take 12 hours to recover?</p>
<hr>
<h2 id="pros-and-cons">Pros and Cons</h2>
<p>For serious technology decisions, the most crucial aspect is weighing the pros and cons. Here, in the order of &ldquo;quality, security, performance, cost,&rdquo; let&rsquo;s discuss the technical trade-offs of placing databases in K8S versus classic bare metal/VM deployments. I don&rsquo;t want to write a comprehensive paper that covers everything. Instead, I&rsquo;ll throw some specific questions for consideration and discussion.</p>
<p><strong>Quality</strong></p>
<p>K8S, compared to physical deployments, introduces additional failure points and architectural complexity, increasing the blast radius and significantly prolonging the average recovery time of failures. In <a href="https://mp.weixin.qq.com/s/kFftay1IokBDqyMuArqOpg">&ldquo;Is it a Good Idea to Put Databases into Docker?&rdquo;</a>, we provided an argument about reliability, which can also apply to Kubernetes — K8S and Docker introduce additional and unnecessary dependencies and failure points to databases, lacking community failure knowledge accumulation and reliability track record (MTTR/MTBF).</p>
<p>In the cloud vendor classification system, K8S belongs to PaaS, while RDS belongs to a more fundamental layer, IaaS. <strong>Database services have higher reliability requirements than K8S</strong>; for instance, many companies&rsquo; cloud management platforms rely on an additional CMDB database. Where should this database be placed? You shouldn&rsquo;t let K8S manage things it depends on, nor should you add unnecessary extra dependencies. The <a href="https://mp.weixin.qq.com/s/OIlR0rolEQff9YfCpj3wIQ">Alibaba Cloud global epic failure</a> and <a href="https://mp.weixin.qq.com/s/FIOB_Oqefx1oez1iu7AGGg">Didi&rsquo;s K8S architecture juggling disaster</a> have taught us this lesson. Moreover, maintaining a separate database system inside K8S when there&rsquo;s already one outside is even more unjustifiable.</p>
<p><strong>Security</strong></p>
<p>The database in a multi-tenant environment introduces additional attack surfaces, bringing higher risks and more complex audit compliance challenges. Does K8S make your database more secure? Maybe the complexity of K8S architecture juggling will deter script kiddies unfamiliar with K8S, but for real attackers, more components and dependencies often mean a broader attack surface.</p>
<p>In <a href="https://mp.weixin.qq.com/s/Tvuy0kAiqh66sOwkr3WWMA">&ldquo;BrokenSesame Alibaba Cloud PostgreSQL Vulnerability Technical Details&rdquo;</a>, security personnel escaped to the K8S host node using their own PostgreSQL container and accessed the K8S API and other tenants&rsquo; containers and data. This is clearly a K8S-specific issue — the risk is real, such attacks have occurred, and even Alibaba Cloud, a local cloud industry leader, has been compromised.</p>
<p><img alt="security.png" src="/zh/blog/db/db-in-k8s/security.png"></p>
<blockquote>
<p>《<a href="https://www.youtube.com/watch?v=d81qnGKv4EE">The Attacker Perspective - Insights From Hacking Alibaba Cloud</a>》</p>
</blockquote>
<p><strong>Performance</strong></p>
<p>As stated in <a href="https://mp.weixin.qq.com/s/kFftay1IokBDqyMuArqOpg">&ldquo;Is it a Good Idea to Put Databases into Docker?&rdquo;</a>, whether it&rsquo;s additional network overhead, Ingress bottlenecks, or underperforming cloud disks, all negatively impact database performance. For example, as revealed in <a href="https://mp.weixin.qq.com/s/SCImfwEvkCPqZhLGx758Sw">&ldquo;PostgreSQL@K8s Performance Optimization&rdquo;</a> — you need a considerable level of technical prowess to make database performance in K8S barely match that on bare metal.</p>
<p><img alt="performence.png" src="/zh/blog/db/db-in-k8s/performence.png"></p>
<blockquote>
<p>Latency is measured in <strong>ms</strong>, not <strong>µs</strong>; I almost thought my eyes were deceiving me.</p>
</blockquote>
<p>Another misconception about efficiency is resource utilization. Unlike offline analytical businesses, critical online OLTP databases should not aim to increase resource utilization but rather deliberately lower it to enhance system reliability and user experience. If there are many fragmented businesses, resource utilization can be improved through PDB/shared database clusters. K8S&rsquo;s advocated elasticity efficiency is not unique to it — KVM/EC2 can also effectively address this issue.</p>
<p>In terms of <strong>cost</strong>, K8S and various Operators provide a decent abstraction, encapsulating some of the complexity of database management, which is attractive for teams without DBAs. However, the complexity reduced by using it to manage databases pales in comparison to the complexity introduced by using K8S itself. For instance, random IP address drifts and automatic Pod restarts may not be a big issue for stateless applications, but for databases, they are intolerable — many companies have had to attempt to modify kubelet to avoid this behavior, thereby introducing more complexity and maintenance costs.</p>
<p>As stated in <a href="https://mp.weixin.qq.com/s/FIOB_Oqefx1oez1iu7AGGg">&ldquo;From Reducing Costs and Smiles to Reducing Costs and Efficiency&rdquo;</a> &ldquo;Reducing Complexity Costs&rdquo; section: <strong>Intellectual power is hard to accumulate spatially</strong>: when a database encounters problems, it needs database experts to solve them; when Kubernetes has problems, it needs K8S experts to look into them; however, when you put a database into Kubernetes, complexities combine, the state space explodes, but the intellectual bandwidth of individual database experts and K8S experts is hard to stack — you need a dual expert to solve the problem, and such experts are undoubtedly much rarer and more expensive than pure database experts. Such architectural juggling is enough to cause major setbacks for most teams, including top public clouds/big companies, in the event of a failure.</p>
<figure class="card rounded p-2 td-post-card mb-4 mt-4" style="max-width: 242px">
<img class="card-img-top" src="/zh/blog/db/db-in-k8s/k8s-meme_huf5d25fac398b63a780ca47347ed1606d_448418_768x300_fit_catmullrom_3.png" width="232" height="300">
</figure>
<hr>
<h2 id="the-cloud-native-frenzy">The Cloud-Native Frenzy</h2>
<p>An interesting question arises: if K8S is unsuitable for stateful databases, why are so many companies, including big players, rushing to do this? The reasons are not technical.</p>
<p>Google open-sourced its K8S battleship, modeled after its internal Borg spaceship, and managers, fearing being left behind, rushed to adopt it, thinking using K8S would put them on par with Google. Ironically, Google doesn&rsquo;t use K8S; it was more likely to disrupt AWS and mislead the industry. However, most companies don&rsquo;t have the manpower like Google to operate such a battleship. More importantly, their problems might need a simple vessel. Running MySQL + PHP, PostgreSQL + Go/Python on bare metal has already taken many companies to IPO.</p>
<p>Under <a href="https://mp.weixin.qq.com/s/1OSRcBfd58s0tgZTUZHB9g">modern hardware conditions</a>, the complexity of most applications throughout their lifecycle doesn&rsquo;t justify using K8S. Yet, the &ldquo;cloud-native&rdquo; frenzy, epitomized by K8S, has become a distorted phenomenon: adopting k8s just for the sake of k8s. Some engineers are looking for &ldquo;advanced&rdquo; and &ldquo;cool&rdquo; technologies used by big companies to fulfill their personal goals like job hopping or promotions or to increase their job security by adding complexity, not considering if these &ldquo;dragon-slaying&rdquo; techniques are necessary for solving their problems.</p>
<p>The cloud-native landscape is filled with fancy projects. Every new development team wants to introduce something new: Helm today, Kubevela tomorrow. They talk big about bright futures and peak efficiency, but in reality, they create a mountain of architectural complexities and a playground for &ldquo;YAML Boys&rdquo; - tinkering with the latest tech, inventing concepts, earning experience and reputation at the expense of users who bear the complexity and maintenance costs.</p>
<p><img alt="cncf-landscape.png" src="/zh/blog/db/db-in-k8s/cncf-landscape.png"></p>
<blockquote>
<p>CNCF Landscape</p>
</blockquote>
<p>The cloud-native movement&rsquo;s philosophy is compelling - democratizing the elastic scheduling capabilities of public clouds for every user. K8S indeed excels in stateless applications. However, excessive enthusiasm has led K8S astray from its original intent and direction - simply doing well in orchestrating stateless applications, burdened by the ill-conceived support for stateful applications.</p>
<hr>
<h2 id="making-wise-decisions">Making Wise Decisions</h2>
<p>Years ago, when I first encountered K8S, I too was fervent —— It was at TanTan. We had over twenty thousand cores and hundreds of database clusters, and I was eager to try putting databases in Kubernetes and testing all the available Operators. However, after two to three years of extensive research and architectural design, I calmed down and abandoned this madness. Instead, I architected our database service based on bare metal/operating systems. For us, the benefits K8S brought to databases were negligible compared to the problems and hassles it introduced.</p>
<p>Should databases be put into K8S? It depends: for public cloud vendors who thrive on overselling resources, elasticity and utilization are crucial, which are directly linked to revenue and profit, While reliability and performance take a back seat - after all, an availability below three nines means <a href="https://vonng.com/cn/blog/cloud/sla/">compensating 25% monthly credit</a>. But for most user, including ourselves, these trade-offs hold different: One-time Day1 Setup, elasticity, and resource utilization aren&rsquo;t their primary concerns; reliability, performance, Day2 Operation costs, these core database attributes are what matter most.</p>
<p>We open-sourced our database service architecture — an out-of-the-box PostgreSQL distribution and a local-first RDS alternative: <a href="https://vonng.com/cn/blog/db/pigsty-intro/">Pigsty</a>. We didn&rsquo;t choose the so-called &ldquo;build once, run anywhere&rdquo; approach of K8S and Docker. Instead, we adapted to different <a href="https://mp.weixin.qq.com/s/xHG8OURTYlmnQTorFkzioA">OS distros</a> &amp; major versions, and used Ansible to achieve a K8S CRD IaC-like API to seal management complexity. This was arduous, but it was the right thing to do - the world does not need another clumsy attempt at putting PostgreSQL into K8S. Still, it does need a production database service architecture that maximizes hardware performance and reliability.</p>
<p><img alt="stackgres-pigsty.png" src="/zh/blog/db/db-in-k8s/pigsty-stackgres.png"></p>
<blockquote>
<p>Pigsty vs StackGres</p>
</blockquote>
<p>Perhaps one day, when the reliability and performance of distributed network storage surpass local storage and mainstream databases have some native support for storage-computation separation, things might change again — K8S might become suitable for databases. But for now, I believe putting serious production OLTP databases into K8S is immature and inappropriate. I hope readers will make wise choices on this matter.</p>
<hr>
<h2 id="reference">Reference</h2>
<p><strong><a href="http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&mid=2247486572&idx=1&sn=274a51976bf8ae5974beb1d3173380c1&chksm=fe4b39b7c93cb0a14c4d99f8ffd1e00c36b972a8058fd99e9d06e6035c4f378b6d327892260b&scene=21#wechat_redirect">Database in Docker: Is that a good idea?</a></strong></p>
<p><strong><a href="https://mp.weixin.qq.com/s/9Q9kze9D2LT0-G2lXSvADg">《Kubernetes is Rotten!》</a></strong></p>
<p><strong><a href="https://mp.weixin.qq.com/s/EWCblHU-vDC3ebV6ITE45A">《Curse of Docker?》</a></strong></p>
<p><strong><a href="https://mp.weixin.qq.com/s/KFZCQFP1oB5YOrT3tHBRCQ">《What can we learn from DiDi&rsquo;s Epic k8s Failure》</a></strong></p>
<p><strong><a href="https://mp.weixin.qq.com/s/0kbWa6AnkCr5jkN4WIgu5Q">《PostgreSQL@K8s Performance Optimization》</a></strong></p>
<p><strong><a href="https://questdb.io/blog/databases-on-k8s/">《Running Database on Kubernetes》</a></strong></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-564f2bc59ef0064fb9b5b78f3ee282ef">NewSQL: Distributive Nonsens</h1>
	
	<div class="td-byline mb-4">
		By <b><a href="https://vonng.com/en/">Ruohang Feng</a> (<a href="https://vonng.com/en/">@Vonng</a>) | <a href="https://mp.weixin.qq.com/s/-eaCoZR9Z5srQ-1YZm1QJA">Wechat Column</a></b> |
        
		<time datetime="2023-05-07" class="text-muted">2023-05-07</time>
        
	</div>
	<blockquote>
<p><a href="https://mp.weixin.qq.com/s/-eaCoZR9Z5srQ-1YZm1QJA">WeChat Column</a></p>
</blockquote>
<p>As hardware technology advances, the capacity and performance of standalone databases have reached unprecedented heights. In this transformative era, distributed (TP) databases appear utterly powerless, much like the &ldquo;data middle platform,&rdquo; donning the emperor&rsquo;s new clothes in a state of self-deception.</p>
<ul>
<li><a href="/blog/db/distributive-bullshit/#tl-dr">TL; DR</a></li>
<li><a href="/blog/db/distributive-bullshit/#the-pull-of-the-internet">The Pull of the Internet</a></li>
<li><a href="/blog/db/distributive-bullshit/#the-trade-offs-of-distributive">The Trade-Offs of Distributive</a></li>
<li><a href="/blog/db/distributive-bullshit/#the-impact-of-new-hardware">The Impact of New Hardware</a></li>
<li><a href="/blog/db/distributive-bullshit/#the-predicament-of-false-needs">The Predicament of False Needs</a></li>
<li><a href="/blog/db/distributive-bullshit/#the-struggles-in-confusion">The Struggles in Confusion</a></li>
<li><a href="/blog/db/distributive-bullshit/#references">References</a></li>
</ul>
<hr>
<h2 id="tl-dr">TL; DR</h2>
<p>The core trade-off of distributed databases is: &ldquo;<strong>quality for quantity</strong>,&rdquo; sacrificing functionality, performance, complexity, and reliability for greater data capacity and throughput. However, &ldquo;what divides must eventually converge,&rdquo; and hardware innovations have propelled centralized databases to new heights in capacity and throughput, rendering distributed (TP) databases obsolete.</p>
<p>Hardware, exemplified by NVMe SSDs, follows Moore&rsquo;s Law, evolving at an exponential pace. Over a decade, performance has increased by tens of times, and prices have dropped significantly, <strong>improving the cost-performance ratio by three orders of magnitude</strong>. A single card can now hold 32TB+, with 4K random read/write IOPS reaching 1600K/600K, latency at 70µs/10µs, and a cost of less than 200 ¥/TB·year. Running a centralized database on a single machine can achieve one to two million point write/point query QPS.</p>
<p>Scenarios truly requiring distributed databases are few and far between, with typical mid-sized internet companies/banks handling request volumes ranging from tens to hundreds of thousands of QPS, and non-repetitive TP data at the hundred TB level. <strong>In the real world, over 99% of scenarios do not need distributed databases</strong>, and the remaining 1% can likely be addressed through classic engineering solutions like horizontal/vertical partitioning.</p>
<p>Top-tier internet companies might have a few genuine use cases, yet these companies have no intention to pay. The market simply cannot sustain so many distributed database cores, and the few products that do survive don&rsquo;t necessarily rely on distribution as their selling point. HATP and the integration of distributed and standalone databases represent the struggles of confused distributed TP database vendors seeking transformation, but they are still far from achieving product-market fit.</p>
<hr>
<h2 id="the-pull-of-the-internet">The Pull of the Internet</h2>
<p>&ldquo;Distributed database&rdquo; is not a term with a strict definition. In a narrow sense, it highly overlaps with NewSQL databases such as CockroachDB, YugabyteDB, TiDB, OceanBase, and TDSQL; broadly speaking, classic databases like Oracle, PostgreSQL, MySQL, SQL Server, PolarDB, and Aurora, which span multiple physical nodes and use master-slave replication or shared storage, can also be considered distributed databases. <strong>In the context of this article, a distributed database refers to the former, specifically focusing on transactional processing (OLTP) distributed relational databases</strong>.</p>
<p>The rise of distributed databases stemmed from the rapid development of internet applications and the explosive growth of data volumes. In that era, traditional relational databases often encountered performance bottlenecks and scalability issues when dealing with massive data and high concurrency. Even using Oracle with Exadata struggled in the face of voluminous CRUD operations, not to mention the prohibitively expensive annual hardware and software costs.</p>
<p>Internet companies embarked on a different path, building their infrastructure with free, open-source databases like MySQL. Veteran developers/DBAs might still recall the MySQL best practice: keep single-table records below 21 million to avoid rapid performance degradation. Correspondingly, database sharding became a widely recognized practice among large companies.</p>
<p>The basic idea here was &ldquo;three cobblers with their wits combined equal Zhuge Liang,&rdquo; using a bunch of inexpensive x86 servers + numerous sharded open-source database instances to create a massive CRUD simple data store. Thus, <strong>distributed databases often originated from internet company scenarios, evolving along the manual sharding → sharding middleware → distributed database path</strong>.</p>
<p>As an industry solution, distributed databases have successfully met the needs of internet companies. However, before abstracting and solidifying it into a product for external output, several questions need to be clarified:</p>
<p><strong>Do the trade-offs from ten years ago still hold up today?</strong></p>
<p><strong>Are the scenarios of internet companies applicable to other industries?</strong></p>
<p><strong>Could distribute OLTP databases be a false necessity?</strong></p>
<hr>
<h2 id="the-trade-offs-of-distributive">The Trade-Offs of Distributive</h2>
<p>&ldquo;Distributed,&rdquo; along with buzzwords like &ldquo;HTAP,&rdquo; &ldquo;compute-storage separation,&rdquo; &ldquo;Serverless,&rdquo; and &ldquo;lakehouse,&rdquo; holds no inherent meaning for enterprise users. Practical clients focus on tangible attributes and capabilities: functionality, performance, security, reliability, return on investment, and cost-effectiveness. <strong>What truly matters is the trade-off: compared to classic centralized databases, what do distributed databases sacrifice, and what do they gain in return?</strong></p>
<p><img alt="distributive-bullshit-1.png" src="/zh/blog/db/distributive-bullshit/distributive-bullshit-1.png"></p>
<blockquote>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&mid=2247485399&idx=1&sn=0b7d5a7dc24295afcc56ec688b2c2d06&chksm=fe4b320cc93cbb1a369f9c9a7c50811c6a4f784fd2dd070f6ce5b16378502b8e5c7c76b716e1&scene=21#wechat_redirect">数据库需求层次金字塔</a>[1]</p>
</blockquote>
<p><strong>The core trade-off of distributed databases can be summarized as &ldquo;quality for quantity&rdquo;: sacrificing functionality, performance, complexity, and reliability to gain greater data capacity and request throughput.</strong></p>
<p>NewSQL often markets itself on the concept of &ldquo;distribution,&rdquo; solving <strong>scalability</strong> issues through &ldquo;distribution.&rdquo; Architecturally, it typically features multiple peer data nodes and a coordinator, employing distributed consensus protocols like Paxos/Raft for replication, allowing for <strong>horizontal scaling</strong> by adding data nodes.</p>
<p><strong>Firstly</strong>, due to their inherent limitations, distributed databases sacrifice many <strong>features</strong>, offering only basic and limited CRUD query support. <strong>Secondly</strong>, because distributed databases require multiple network RPCs to complete requests, their <strong>performance</strong> typically suffers a 70% or more degradation compared to centralized databases. <strong>Furthermore</strong>, distributed databases, consisting of DN/CN and TSO components among others, introduce significant <strong>complexity</strong> in operations and management. <strong>Lastly</strong>, in terms of <strong>high availability and disaster recovery</strong>, distributed databases do not offer a qualitative improvement over the classic centralized master-slave setup; instead, they introduce numerous additional failure points due to their complex components.</p>
<p><img alt="distributive-bullshit-2.png" src="/zh/blog/db/distributive-bullshit/distributive-bullshit-2.png"></p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/651zXDKGwFy8i0Owrmm-Xg">SYSBENCH吞吐对比</a>[2]</p>
</blockquote>
<p>In the past, the trade-offs of distributed databases were justified: the internet required larger data storage capacities and higher access throughputs—a must-solve problem, and these drawbacks were surmountable. But today, hardware advancements have rendered the &ldquo;quantity&rdquo; question obsolete, thus erasing the raison d&rsquo;être of distributed databases along with the very problem they sought to solve.</p>
<p><img alt="distributive-bullshit-3.png" src="/zh/blog/db/distributive-bullshit/distributive-bullshit-3.png"></p>
<blockquote>
<p>Times have changed, My lord!</p>
</blockquote>
<hr>
<h2 id="the-impact-of-new-hardware">The Impact of New Hardware</h2>
<p>Moore&rsquo;s Law posits that every 18 to 24 months, processor performance doubles while costs halve. This principle largely applies to storage as well. From 2013 to 2023, spanning 5 to 6 cycles, we should see performance and cost differences of <strong>dozens of times</strong> compared to a decade ago. Is this the case?</p>
<p>Let&rsquo;s examine the performance metrics of a typical SSD from 2013 and compare them with those of a typical PCI-e Gen4 NVMe SSD from 2022. It&rsquo;s evident that the SSD&rsquo;s 4K random read/write IOPS have jumped from <strong>60K/40K</strong> to <strong>1600K/600K</strong>, with prices plummeting from <strong>2220$/TB</strong> to <strong>40$/TB</strong>. Performance has improved by 15 to 26 times, while prices have dropped 56-fold[3,4,5], certainly validating the rule of thumb at a magnitude level.</p>
<p><img alt="distributive-bullshit-4.png" src="/zh/blog/db/distributive-bullshit/distributive-bullshit-4.png"></p>
<blockquote>
<p>HDD/SSD Performance in 2013</p>
</blockquote>
<p><img alt="distributive-bullshit-5.png" src="/zh/blog/db/distributive-bullshit/distributive-bullshit-5.png"></p>
<blockquote>
<p>NVMe Gen4 SSD in 2022</p>
</blockquote>
<p>A decade ago, mechanical hard drives dominated the market. A 1TB hard drive cost about seven or eight hundred yuan, and a 64GB SSD was even more expensive. Ten years later, a mainstream 3.2TB enterprise-grade NVMe SSD costs just three thousand yuan. Considering a five-year warranty, the monthly cost per TB is only <strong>16</strong> yuan, with an annual cost under <strong>200</strong> yuan. For reference, cloud providers&rsquo; reputedly cost-effective S3 object storage costs <strong>1800¥/TB·year.</strong></p>
<p><img alt="distributive-bullshit-6.png" src="/zh/blog/db/distributive-bullshit/distributive-bullshit-6.png"></p>
<blockquote>
<p>Price per unit of SSD/HDD from 2013 to 2030 with predictions</p>
</blockquote>
<p>The typical fourth-generation local NVMe disk can reach a maximum capacity of <strong>32TB to 64TB</strong>, offering <strong>70µs/10µs</strong> 4K random read/write latencies, and <strong>1600K/600K</strong> read/write IOPS, with the fifth generation boasting an astonishing bandwidth of <strong>several GB/s</strong> per card.</p>
<p>Equipping a classic Dell 64C / 512G server with such a card, factoring in five years of IDC depreciation, the total cost is under one hundred thousand yuan. Such a server running PostgreSQL <strong>sysbench</strong> can nearly reach one million QPS for single-point writes and two million QPS for point queries without issue.</p>
<p>What does this mean? For a typical mid-sized internet company/bank, the demand for database requests is usually in the tens of thousands to hundreds of thousands of QPS, with non-repeated TP data volumes fluctuating around hundreds of TBs. Considering hardware storage compression cards can achieve several times compression ratio, such scenarios might now be manageable by a centralized database on a single machine and card under modern hardware conditions[6].</p>
<p>Previously, users might have had to invest millions in high-end storage solutions like exadata, then spend a fortune on Oracle commercial database licenses and original factory services. Now, achieving similar outcomes starts with just a few thousand yuan on an enterprise-grade SSD card; open-source Oracle alternatives like PostgreSQL, capable of smoothly running the largest single tables of 32TB, no longer suffer from the limitations that once forced MySQL into partitioning. High-performance database services, once luxury items restricted to intelligence/banking sectors, have become affordable for all industries[7].</p>
<p><strong>Cost-effectiveness is the primary product strength</strong>. The cost-effectiveness of high-performance, large-capacity storage has improved by three orders of magnitude over a decade, making the once-highlighted value of distributed databases appear weak in the face of such remarkable hardware evolution.</p>
<hr>
<h2 id="the-predicament-of-false-needs">The Predicament of False Needs</h2>
<p>Nowadays, sacrificing functionality, performance, complexity for scalability is most likely to be a fake-demands in most scenarios.</p>
<p>With the support of modern hardware, over 99% of real-world scenarios do not exceed the capabilities of a centralized, single-machine database. The remaining scenarios can likely be addressed through classical engineering methods like horizontal or vertical splitting. This holds true even for internet companies: even among the global top firms, scenarios where a transactional (TP) single table exceeds several tens of TBs are still rare.</p>
<p>Google Spanner, the forefather of NewSQL, was designed to solve the problem of massive data scalability, but how many enterprises actually handle data volumes comparable to Google&rsquo;s? In terms of data volume, the lifetime TP data volume for the vast majority of enterprises will not exceed the bottleneck of a centralized database, which continues to grow exponentially with Moore&rsquo;s Law. Regarding request throughput, many enterprises have enough database performance headroom to implement all their business logic in stored procedures and run it smoothly within the database.</p>
<p>&ldquo;<em>Premature optimization is the root of all evil</em>,&rdquo; designing for unneeded scale is a waste of effort. If volume is no longer an issue, then sacrificing other attributes for unneeded volume becomes meaningless.</p>
<p><img alt="distributive-bullshit-7.png" src="/zh/blog/db/distributive-bullshit/distributive-bullshit-7.png"></p>
<blockquote>
<p>“Premature optimization is the root of all evil”</p>
</blockquote>
<p><strong>In many subfields of databases, distributed technology is not a pseudo-requirement</strong>: if you need a highly reliable, disaster-resilient, simple, low-frequency KV storage for metadata, then a distributed etcd is a suitable choice; if you require a globally distributed table for arbitrary reads and writes across different locations and are willing to endure significant performance degradation, then YugabyteDB might be a good choice. For ensuring transparency and preventing tampering and denial, blockchain is fundamentally a leaderless distributed ledger database;</p>
<p>For large-scale data analytics (OLAP), distributed technology is <strong>indispensable</strong> (though this is usually referred to as data warehousing, MPP); however, in the transaction processing (OLTP) domain, distributed technology is <strong>largely unnecessary</strong>: OLTP databases are like working memory, characterized by being small, fast, and feature-rich. Even in very large business systems, the active working set at any one moment is not particularly large. A basic rule of thumb for OLTP system design is: <strong>If your problem can be solved within a single machine, don&rsquo;t bother with distributed databases</strong>.</p>
<p><strong>OLTP</strong> databases have a history spanning several decades, with existing cores developing to a mature stage. Standards in the TP domain are gradually converging towards three Wire Protocols: PostgreSQL, MySQL, and Oracle. If the discussion is about tinkering with database auto-sharding and adding global transactions as a form of &ldquo;distribution,&rdquo; it&rsquo;s definitely a dead end. If a &ldquo;distributed&rdquo; database manages to break through, it&rsquo;s likely not because of the &ldquo;pseudo-requirement&rdquo; of &ldquo;distribution,&rdquo; but rather due to new features, open-source ecosystems, compatibility, ease of use, domestic innovation, and self-reliance.</p>
<hr>
<h2 id="the-struggles-in-confusion">The Struggles in Confusion</h2>
<p>The greatest challenge for distributed databases stems from the market structure: <strong>Internet companies, the most likely candidates to utilize distributed TP databases, are paradoxically the least likely to pay for them</strong>. Internet companies can serve as high-quality users or even contributors, offering case studies, feedback, and PR, but they inherently resist the notion of financially supporting software, clashing with their <strong>meme instincts</strong>. Even leading distributed database vendors face the challenge of being applauded but not financially supported.</p>
<p>In a recent casual conversation with an engineer at a distributed database company, it was revealed that during a POC with a client, a query that Oracle completed in 10 seconds, their distributed database could only match with an order of magnitude difference, even when utilizing various resources and Dirty Hacks. Even openGauss, which forked from PostgreSQL 9.2 a decade ago, can outperform many distributed databases in certain scenarios, not to mention the advancements seen in PostgreSQL 15 and Oracle 23c ten years later. This gap is so significant that even the original manufacturers are left puzzled about the future direction of distributed databases.</p>
<p>Thus, some distributed databases have started pivoting towards self-rescue, with <strong>HTAP</strong> being a prime example: while transaction processing in a distributed setting is suboptimal, analytics can benefit greatly. So, why not combine the two? A single system capable of handling both transactions and analytics! However, engineers in the real world understand that <strong>AP systems and TP systems each have their own patterns, and forcibly merging two diametrically opposed systems will only result in both tasks failing to succeed</strong>. Whether it&rsquo;s classic ETL/CDC pushing and pulling to specialized solutions like ClickHouse/Greenplum/Doris, or logical replication to a dedicated in-memory columnar store, any of these approaches is more reliable than using a chimera HTAP database.</p>
<p>Another idea is <strong>monolithic-distributed integration</strong>: <strong>if you can&rsquo;t beat them, join them</strong> by adding a monolithic mode to avoid the high costs of network RPCs, ensuring that in 99% of scenarios where distributed capabilities are unnecessary, they aren&rsquo;t completely outperformed by centralized databases — <strong>even if distributed isn&rsquo;t needed, it&rsquo;s essential to stay in the game and prevent others from taking the lead!</strong> But the fundamental issue here is the same as with HTAP: forcing heterogeneous data systems together is pointless. If there was value in doing so, why hasn&rsquo;t anyone created a monolithic binary that integrates all heterogeneous databases into a do-it-all behemoth — <strong>the Database Jack-of-all-trades?</strong> Because it violates the KISS principle: <strong>Keep It Simple, Stupid!</strong></p>
<p><img alt="distributive-bullshit-8.png" src="/zh/blog/db/distributive-bullshit/distributive-bullshit-8.png"></p>
<p>The plight of distributed databases is similar to that of <strong>Middle Data Platforms</strong>: originating from internal scenarios at major internet companies and solving domain-specific problems. Once riding the wave of the internet industry, the discussion of databases was dominated by distributed technologies, enjoying a moment of pride. However, due to excessive hype and promises of unrealistic capabilities, they failed to meet user expectations, ending in disappointment and becoming akin to the emperor&rsquo;s new clothes.</p>
<p>There are still many areas within the TP database field worthy of focus: Leveraging new hardware, actively embracing changes in underlying architectures like CXL, RDMA, NVMe; or providing simple and intuitive declarative interfaces to make database usage and management more convenient; offering more intelligent automatic monitoring and control systems to minimize operational tasks; developing compatibility plugins like Babelfish for MySQL/Oracle, aiming for a unified relational database WireProtocol. Even investing in better support services would be more meaningful than chasing the false need for &ldquo;distributed&rdquo; features.</p>
<p>Time changes, and a wise man adapts. It is hoped that distributed database vendors will find their Product-Market Fit and focus on what users truly need.</p>
<hr>
<h2 id="references">References</h2>
<p>[1] <a href="http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&mid=2247485399&idx=1&sn=0b7d5a7dc24295afcc56ec688b2c2d06&chksm=fe4b320cc93cbb1a369f9c9a7c50811c6a4f784fd2dd070f6ce5b16378502b8e5c7c76b716e1&scene=21#wechat_redirect">数据库需求层次金字塔 </a>: <em><a href="https://mp.weixin.qq.com/s/1xR92Z67kvvj2_NpUMie1Q">https://mp.weixin.qq.com/s/1xR92Z67kvvj2_NpUMie1Q</a></em></p>
<p>[2] <a href="http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&mid=2247485240&idx=1&sn=9052f03ae2ef21d9e21037fd7a1fa7fe&chksm=fe4b32e3c93cbbf522616346c1afd49e1e6edbb0898694df224fe2134a69c0c4562aab35587a&scene=21#wechat_redirect">PostgreSQL到底有多强？</a> : <em><a href="https://mp.weixin.qq.com/s/651zXDKGwFy8i0Owrmm-Xg">https://mp.weixin.qq.com/s/651zXDKGwFy8i0Owrmm-Xg</a></em></p>
<p>[3] SSD Performence in 2013 : <em><a href="https://www.snia.org/sites/default/files/SNIASSSI.SSDPerformance-APrimer2013.pdf">https://www.snia.org/sites/default/files/SNIASSSI.SSDPerformance-APrimer2013.pdf</a></em></p>
<p>[4] 2022 Micron NVMe SSD Spec: <em><a href="https://media-www.micron.com/-/media/client/global/documents/products/product-flyer/9400_nvme_ssd_product_brief.pdf">https://media-www.micron.com/-/media/client/global/documents/products/product-flyer/9400_nvme_ssd_product_brief.pdf</a></em></p>
<p>[5] 2013-2030 SSD Pricing : <em><a href="https://blocksandfiles.com/2021/01/25/wikibon-ssds-vs-hard-drives-wrights-law/">https://blocksandfiles.com/2021/01/25/wikibon-ssds-vs-hard-drives-wrights-law/</a></em></p>
<p>[6] <a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ0MDQxNg==&mid=2247516311&idx=1&sn=b93dc765a952f998ccea6e85ebfb7b8d&scene=21#wechat_redirect">Single Instance with 100TB</a>: <a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ0MDQxNg==&mid=2247516311&idx=1&sn=b93dc765a952f998ccea6e85ebfb7b8d&scene=21#wechat_redirect"><em>https://mp.weixin.qq.com/s/JSQPzep09rDYbM-x5ptsZA</em></a></p>
<p>[7] <a href="http://mp.weixin.qq.com/s?__biz=MzU5ODAyNTM5Ng==&mid=2247485391&idx=1&sn=4cec9af2b58160eb345a6b12411f0b68&chksm=fe4b3214c93cbb023c13a89133c75bf1e88e1543de9359df7447498e4a9d5ec555313a954566&scene=21#wechat_redirect">EBS: Scam</a>: <em><a href="https://mp.weixin.qq.com/s/UxjiUBTpb1pRUfGtR9V3ag">https://mp.weixin.qq.com/s/UxjiUBTpb1pRUfGtR9V3ag</a></em></p>
<p>[8] <a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjcyNDk3MQ==&mid=2247486918&idx=1&sn=c1c0331b01e2c91e65ec6ed755093582&scene=21#wechat_redirect">中台：一场彻头彻尾的自欺欺人</a>: <em><a href="https://mp.weixin.qq.com/s/VgTU7NcOwmrX-nbrBBeH_w">https://mp.weixin.qq.com/s/VgTU7NcOwmrX-nbrBBeH_w</a></em></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-65bb532e2949268a0bd020d4878070be">Is running postgres in docker a good idea?</h1>
	<div class="lead">Thou shalt not run a prod database inside a container</div>
	<div class="td-byline mb-4">
		By <b><a href="https://vonng.com/en/">Ruohang Feng</a> (<a href="https://vonng.com/en/">@Vonng</a>)</b> |
        
		<time datetime="2019-01-13" class="text-muted">2019-01-13</time>
        
	</div>
	<p>For stateless app services, containers are an almost perfect devops solution. However, for stateful services like databases, it&rsquo;s not so straightforward. Whether production databases should be containerized remains controversial.</p>
<p>From a developer&rsquo;s perspective, I&rsquo;m a big fan of Docker &amp; Kubernetes and believe that they might be the future standard for software deployment and operations. But as a database administrator, I think hosting production databases in Docker/K8S is still a bad idea.</p>
<hr>
<h2 id="what-problems-does-docker-solve">What problems does Docker solve?</h2>
<p>Docker is described with terms like lightweight, standardized, portable, cost-effective, efficient, automated, integrated, and high-performance in operations. These claims are valid, as Docker indeed simplifies both development and operations. This explains why many companies are eager to containerize their software and services. However, this enthusiasm sometimes goes to the extreme of containerizing everything, including <strong>production databases</strong>.</p>
<p>Containers were originally designed for <strong>stateless</strong> apps, where temporary data produced by the app is logically part of the container. A service is created with a container and destroyed after use. These apps are stateless, with the state typically stored outside in a database, reflecting the classic architecture and philosophy of containerization.</p>
<p>But when it comes to containerizing the production database itself, the scenario changes: databases are stateful. To maintain their state without losing it when the container stops, database containers need to &ldquo;punch a hole&rdquo; to the underlying OS, which is named data volumes.</p>
<p>Such containers are no longer ephemeral entities that can be freely created, destroyed, moved, or transferred; they become bound to the underlying environment. Thus, the many advantages of using containers for traditional apps are not applicable to database containers.</p>
<hr>
<h2 id="reliability">Reliability</h2>
<p>Getting software up &amp; running is one thing; ensuring its reliability is another. Databases, central to information systems, are often critical, with failure leading to catastrophic consequences. This reflects common experience: while office software crashes can be tolerated and resolved with restarts, document loss or corruption is unresolvable and disastrous. Database failure without replica &amp; backups can be terminal, particularly for internet/finance companies.</p>
<p><strong>Reliability</strong> is the paramount attribute for databases. It&rsquo;s the system&rsquo;s ability to function correctly during adversity (hardware/software faults, human error), i.e. fault tolerance and resilience. Unlike <strong>liveness attribute</strong> such as performance, reliability, a safety attribute, proves itself over time or falsify by failures, often overlooked until disaster strikes.</p>
<p>Docker&rsquo;s description notably omits &ldquo;reliability&rdquo; —— the crucial attribute for database.</p>
<h3 id="reliability-proof">Reliability Proof</h3>
<p>As mentioned, reliability lacks a definitive measure. Confidence in a system&rsquo;s reliability builds over time through consistent, correct operation (MTTF). Deploying databases on bare metal has been a long-standing practice, proven reliable over decades. Docker, despite revolutionizing DevOps, has a mere ten-year track record, which is insufficient for establishing reliability, especially for mission-critical production databases. In essence, <strong>there haven&rsquo;t been enough &ldquo;guinea pigs&rdquo; to clear the minefield</strong>.</p>
<h3 id="community-knowledge">Community Knowledge</h3>
<p>Improving reliability hinges on learning from failures. Failures are invaluable, turning unknowns into knowns and forming the bedrock of operational knowledge. <strong>Community experience with failures is predominantly based on bare-metal deployments</strong>, with a plethora of issues well-trodden over decades. Encountering a problem often means finding a well-documented solution, thanks to previous experiences. However, add &ldquo;Docker&rdquo; to the mix, and the pool of useful information shrinks significantly. This implies a lower success rate in data recovery and longer times to resolve complex issues when they arise.</p>
<blockquote>
<p>A subtle reality is that, without compelling reasons, businesses and individuals are generally reluctant to share experiences with failures. Failures can tarnish a company’s reputation, potentially exposing sensitive data or reflecting poorly on the organization and team. Moreover, insights from failures are often the result of costly lessons and financial losses, representing core value for operations personnel, thus public documentation on failures is scarce.</p>
</blockquote>
<h3 id="extra-failure-point">Extra Failure Point</h3>
<p>Running databases in Docker doesn&rsquo;t reduce the chances of hardware failures, software bugs, or human errors. Hardware issues persist with or without Docker. Software defects, mainly application bugs, aren&rsquo;t lessened by containerization, and the same goes for human errors. In fact, Docker introduces <strong>extra components, complexity, and failure points, decreasing overall system reliability</strong>.</p>
<p>Consider this simple scenario: if the Docker daemon crashes, the database process dies. Such incidents, albeit rare, are non-existent on bare-metal.</p>
<p>Moreover, the failure points from an additional component like Docker aren’t limited to Docker itself. Issues could arise from interactions between Docker and the database, the OS, orchestration systems, VMs, networks, or disks. For evidence, see the issue tracker for the official PostgreSQL Docker image: <a href="https://github.com/docker-library/postgres/issues?q=">https://github.com/docker-library/postgres/issues?q=</a>.</p>
<p><strong>Intellectual power doesn&rsquo;t easily stack</strong> — a team&rsquo;s intellect relies on the few seasoned members and their communication overhead. Database issues require database experts; container issues, container experts. However, when databases are deployed on kubernetes &amp; dockers, merging the expertise of database and K8S specialists is challenging — you need a dual-expert to resolve issues, and such individuals are rarer than specialists in one domain.</p>
<p>Moreover, one man&rsquo;s meat is another man&rsquo;s poison. Certain Docker features might turn into bugs under specific conditions.</p>
<h3 id="unnecessary-isolation">Unnecessary Isolation</h3>
<p>Docker provides process-level isolation, which generally benefits applications by reducing interaction-related issues, thereby enhancing system reliability. However, this isolation isn&rsquo;t always advantageous for databases.</p>
<p>A subtle <strong>real-world case</strong> involved starting two PostgreSQL server on the same data directory, either on the host or one in the host and another inside a container. On bare metal, the second instance would fail to start as PostgreSQL recognizes the existing instance and refuses to launch; however, Docker&rsquo;s <strong>isolation</strong> allows the second instance to start obliviously, potentially <strong>toast</strong> the data files if proper fencing mechanisms (like host port or PID file exclusivity) aren&rsquo;t in place.</p>
<p>Do databases need isolation? Absolutely, but not this kind. Databases often demand dedicated physical machines for performance reasons, with only the database process and essential tools running. Even in containers, they&rsquo;re typically bound exclusively to physical/virtual machines. Thus, the type of isolation Docker provides is somewhat irrelevant for such deployments, though it is a handy feature for cloud providers to efficiently oversell in a multi-tenant environment.</p>
<hr>
<h2 id="maintainability">Maintainability</h2>
<blockquote>
<p>Docker simplify the day one setup, but bring much more troubles on day two operation.</p>
</blockquote>
<p>The bulk of software expenses isn&rsquo;t in initial development but in ongoing maintenance, which includes fixing vulnerabilities, ensuring operational continuity, handling outages, upgrading versions, repaying technical debt, and adding new features. Maintainability is crucial for the quality of life in operations work. Docker shines in this aspect with its infrastructure-as-code approach, effectively turning operational knowledge into reusable code, accumulating it in a streamlined manner rather than scattered across various installation/setup documents. Docker excels here, especially for stateless applications with frequently changing logic. Docker and Kubernetes facilitate deployment, scaling, publishing, and rolling upgrades, allowing Devs to perform Ops tasks, and Ops to handle DBA duties (somewhat convincingly).</p>
<h3 id="day-1-setup">Day 1 Setup</h3>
<p>Perhaps Docker&rsquo;s greatest strength is the standardization of environment configuration. A standardized environment aids in delivering changes, discussing issues, and reproducing bugs. Using binary images (essentially materialized Dockerfile installation scripts) is quicker and easier to manage than running installation scripts. Not having to rebuild complex, dependency-heavy extensions each time is a notable advantage.</p>
<p>Unfortunately, databases don&rsquo;t behave like typical business applications with frequent updates, and creating new instances or delivering environments is a rare operation. Additionally, DBAs often accumulate various installation and configuration scripts, making environment setup almost as fast as using Docker. Thus, Docker&rsquo;s advantage in environment configuration isn&rsquo;t as pronounced, falling into the &ldquo;nice to have&rdquo; category. Of course, in the absence of a dedicated DBA, using Docker images might still be preferable as they encapsulate some operational experience.</p>
<p>Typically, it&rsquo;s not unusual for databases to run continuously for months or years after initialization. The primary aspect of database management isn&rsquo;t creating new instances or delivering environments, but the day-to-day operations — Day2 Operation. Unfortunately, Docker doesn&rsquo;t offer much benefit in this area and can introduce additional complications.</p>
<h3 id="day2-operation">Day2 Operation</h3>
<p>Docker can significantly streamline the maintenance of stateless apps, enabling easy create/destroy, version upgrades, and scaling. However, does this extend to databases?</p>
<p>Unlike app containers, database containers can&rsquo;t be freely destroyed or created. Docker doesn&rsquo;t enhance the operational experience for databases; tools like Ansible are more beneficial. Often, operations require executing scripts inside containers via <code>docker exec</code>, adding unnecessary complexity.</p>
<p>CLI tools often struggle with Docker integration. For instance, <code>docker exec</code> mixes <code>stderr</code> and <code>stdout</code>, breaking pipeline-dependent commands. In bare-metal deployments, certain ETL tasks for PostgreSQL can be easily done with a single Bash line.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>psql &lt;src-url&gt; -c <span style="color:#4e9a06">&#39;COPY tbl TO STDOUT&#39;</span> <span style="color:#000;font-weight:bold">|</span> psql &lt;dst-url&gt; -c <span style="color:#4e9a06">&#39;COPY tdb FROM STDIN&#39;</span>
</span></span></code></pre></div><p>Yet, without proper client binaries on the host, one must awkwardly use Docker&rsquo;s binaries like:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker <span style="color:#204a87">exec</span> -it srcpg gosu postgres bash -c <span style="color:#4e9a06">&#34;psql -c \&#34;COPY tbl TO STDOUT\&#34; 2&gt;/dev/null&#34;</span> <span style="color:#000;font-weight:bold">|</span><span style="color:#4e9a06">\ </span>
</span></span><span style="display:flex;"><span>  docker <span style="color:#204a87">exec</span> -i dstpg gosu postgres psql -c <span style="color:#4e9a06">&#39;COPY tbl FROM STDIN;&#39;</span>
</span></span></code></pre></div><p>complicating simple commands like physical backups, which require layers of command wrapping:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker <span style="color:#204a87">exec</span> -i postgres_pg_1 gosu postgres bash -c <span style="color:#4e9a06">&#39;pg_basebackup -Xf -Ft -c fast -D - 2&gt;/dev/null&#39;</span> <span style="color:#000;font-weight:bold">|</span> tar -xC /tmp/backup/basebackup
</span></span></code></pre></div><blockquote>
<p><code>docker</code>, <code>gosu</code>, <code>bash</code>, <code>pg_basebackup</code></p>
</blockquote>
<p>Client-side applications (<code>psql</code>, <code>pg_basebackup</code>, <code>pg_dump</code>) can bypass these issues with version-matched client tools on the host, but server-side solutions lack such workarounds. Upgrading containerized database software shouldn&rsquo;t necessitate host server binary upgrades.</p>
<p>Docker advocates for easy software versioning; updating a minor database version is straightforward by tweaking the Dockerfile and restarting the container. However, major version upgrades requiring state modification are more complex in Docker, often leading to convoluted processes like those in <a href="https://github.com/tianon/docker-postgres-upgrade">https://github.com/tianon/docker-postgres-upgrade</a>.</p>
<p>If database containers can&rsquo;t be scheduled, scaled, or maintained as easily as AppServers, why use them in production? While stateless apps benefit from Docker and Kubernetes&rsquo; scaling ease, stateful applications like databases don&rsquo;t enjoy such flexibility. Replicating a large production database is time-consuming and manual, questioning the efficiency of using <code>docker run</code> for such operations.</p>
<p>Docker&rsquo;s awkwardness in hosting production databases stems from the stateful nature of databases, requiring additional setup steps. Setting up a new PostgreSQL replica, for instance, involves a local data directory clone and starting the <code>postmaster</code> process. Container lifecycle tied to a single process complicates database scaling and replication, leading to inelegant and complex solutions. This process isolation in containers, or &ldquo;abstraction leakage,&rdquo; fails to neatly cover the multiprocess, multitasking nature of databases, introducing unnecessary complexity and affecting maintainability.</p>
<p>In conclusion, while Docker can improve system maintainability in some aspects, like simplifying new instance creation, the introduced complexities often undermine these benefits.</p>
<h3 id="tooling">Tooling</h3>
<p>Databases require tools for maintenance, including a variety of operational scripts, deployment, backup, archiving, failover, version upgrades, plugin installation, connection pooling, performance analysis, monitoring, tuning, inspection, and repair. Most of these tools are designed for bare-metal deployments. Like databases, these tools need thorough and careful testing. Getting something to run versus ensuring its stable, long-term, and correct operation are distinct levels of reliability.</p>
<p>A simple example is plugin and package management. PostgreSQL offers many useful plugins, such as PostGIS. On bare metal, installing this plugin is as easy as executing <code>yum install</code> followed by <code>create extension postgis</code>. However, in Docker, following best practices requires making changes at the image level to persist the extension beyond container restarts. This necessitates modifying the Dockerfile, rebuilding the image, pushing it to the server, and restarting the database container, undeniably a more cumbersome process.</p>
<p>Package management is a core aspect of OS distributions. Docker complicates this, as many PostgreSQL binaries are distributed not as RPM/DEB packages but as Docker images with pre-installed extensions. This raises a significant issue: how to consolidate multiple disparate images if one needs to use two, three, or over a hundred extensions from the PostgreSQL ecosystem? Compared to reliable OS package management, building Docker images invariably requires more time and effort to function properly.</p>
<p>Take monitoring as another example. In traditional bare-metal deployment, <strong>machine metrics</strong> are crucial for database monitoring. Monitoring in containers differs subtly from that on bare metal, and oversight can lead to pitfalls. For instance, the sum of various CPU mode durations always equals 100% on bare metal, but this assumption doesn&rsquo;t necessarily hold in containers. Moreover, monitoring tools relying on the <code>/proc</code> filesystem may yield metrics in containers that differ significantly from those on bare metal. While such issues are solvable (e.g., mounting the Proc filesystem inside the container), complex and ugly workarounds are generally unwelcome compared to straightforward solutions.</p>
<p>Similar issues arise with some failure detection tools and common system commands. Theoretically, these could be executed directly on the host, but can we guarantee that the results in the container will be identical to those on bare metal? More frustrating is the emergency troubleshooting process, where necessary tools might be missing in the container, and with no external network access, the Dockerfile→Image→Restart path can be exasperating.</p>
<p>Treating Docker like a VM, many tools may still function, but this defeats much of Docker&rsquo;s purpose, reducing it to just another package manager. Some argue that Docker enhances system reliability through standardized deployment, given the more controlled environment. While this is true, I believe that if the personnel managing the database understand how to configure the database environment, there&rsquo;s no fundamental difference between scripting environment initialization in a Shell script or in a Dockerfile.</p>
<hr>
<h2 id="scalability">Scalability</h2>
<p>Performance is another point that people concerned a lot. From the performance perspective, the basic principle of  database deployment is: The close to hardware, The better it is.  Additional isolation &amp; abstraction layer is bad for database performance. More isolation means more overhead, even if it is just an additional <code>memcpy</code> in the kernel .</p>
<p>For performance-seeking scenarios, some databases choose to bypass the operating system&rsquo;s page management mechanism to operate the disk directly, while some databases may even use FPGA or GPU to speed up query processing. Docker as a lightweight container, performance suffers not much, and the impact to performance-insensitive scenarios may not be significant, but the extra abstract layer will definitely make performance worse than make it better.</p>
<hr>
<h2 id="summary">Summary</h2>
<p>Container and orchestration technologies are valuable for operations, bridging the gap between software and services by aiming to codify and modularize operational expertise and capabilities. Container technology is poised to become the future of package management, while orchestration evolves into a &ldquo;data center distributed cluster operating system,&rdquo; forming the underlying infrastructure runtime for all software. As more challenges are addressed, confidently running both stateful and stateless applications in containers will become feasible. However, for databases, this remains an ideal rather than a practical option, especially in production.</p>
<p>It&rsquo;s crucial to reiterate that the above discussion applies specifically to <strong>production databases</strong>. For development and testing, despite the existence of Vagrant-based virtual machine sandboxes, I advocate for Docker use—many developers are unfamiliar with configuring local test database environments, and Docker provides a clearer, simpler solution. For stateless production applications or those with non-critical derivative state data (like Redis caches), Docker is a good choice. But for core relational databases in production, where data integrity is paramount, one should carefully consider the risks and benefits: What&rsquo;s the value of using Docker here? Can it handle potential issues? Are you prepared to assume the responsibility if things go wrong?</p>
<p>Every technological decision involves balancing pros and cons, like the core trade-off here of <strong>sacrificing reliability for maintainability</strong> with Docker. Some scenarios may warrant this, such as cloud providers optimizing for containerization to oversell resources, where container isolation, high resource utilization, and management convenience align well. Here, the benefits might outweigh the drawbacks. However, in many cases, reliability is the top priority, and compromising it for maintainability is not advisable. Moreover, it&rsquo;s debatable whether using Docker significantly eases database management; sacrificing long-term operational maintainability for short-term deployment ease is unwise.</p>
<p>In conclusion, containerizing production databases is likely not a prudent choice.</p>

</div>





    
	
  



          </main>
        </div>
      </div>
      <footer class="td-footer row d-print-none">
  <div class="container-fluid">
    <div class="row mx-md-2">
      <div class="td-footer__left col-6 col-sm-4 order-sm-1">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Mail" aria-label="Mail">
    <a target="_blank" rel="noopener" href="mailto:rh@vonng.com" aria-label="Mail">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="GitHub" aria-label="GitHub">
    <a target="_blank" rel="noopener" href="https://github.com/Vonng/pigsty" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Twitter" aria-label="Twitter">
    <a target="_blank" rel="noopener" href="https://twitter.com/GobeUncleWang" aria-label="Twitter">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__right col-6 col-sm-4 order-sm-3">
        <ul class="td-footer__links-list">
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="WeChat" aria-label="WeChat">
    <a target="_blank" rel="noopener" href="/img/pigsty/pigsty-cc.jpg" aria-label="WeChat">
      <i class="fa fa-comment"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Discord" aria-label="Discord">
    <a target="_blank" rel="noopener" href="https://discord.gg/wDzt5VyWEz" aria-label="Discord">
      <i class="fab fa-discord"></i>
    </a>
  </li>
  
  <li class="td-footer__links-item" data-bs-toggle="tooltip" title="Telegram" aria-label="Telegram">
    <a target="_blank" rel="noopener" href="https://t.me/joinchat/gV9zfZraNPM3YjFh" aria-label="Telegram">
      <i class="fab fa-telegram"></i>
    </a>
  </li>
  
</ul>

      </div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2">
        <span class="td-footer__copyright">&copy;
    2018&ndash;2024
    <span class="td-footer__authors">Ruohang Feng</span></span><span class="td-footer__all_rights_reserved">All Rights Reserved</span></span><span class="ms-2"><a href="https://vonng.com/en/" target="_blank" rel="noopener">@Vonng</a></span>
<br><span>Pigsty® distributed under <a href="/docs/about/license" target="_blank" rel="noopener">AGPLv3</a></span>
<br><span class="ms-2"><a href="/docs/about/privacy" target="_blank" rel="noopener">Privacy Policy</a></span>
<span><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">浙ICP备15016890号</a></span>
      </div>
    </div>
  </div>
</footer>

    </div>
    <script src="/js/main.min.248655eb216150e39da254c2f7aa5357805d0ec66bdb741b591cd35fb5f629ab.js" integrity="sha256-JIZV6yFhUOOdolTC96pTV4BdDsZr23QbWRzTX7X2Kas=" crossorigin="anonymous"></script>
<script defer src="/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js" integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin="anonymous"></script>
<script src='/js/tabpane-persist.js'></script>

  </body>
</html>
